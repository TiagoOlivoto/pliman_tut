[
  {
    "objectID": "04_phytopathometry.html",
    "href": "04_phytopathometry.html",
    "title": "Phytopathometry",
    "section": "",
    "text": "setwd(\"E:/Desktop/UFSC/cursos/pliman_tut/imgs\")"
  },
  {
    "objectID": "04_phytopathometry.html#producing-sample-palettes",
    "href": "04_phytopathometry.html#producing-sample-palettes",
    "title": "Phytopathometry",
    "section": "\n4.1 Producing sample palettes",
    "text": "4.1 Producing sample palettes\nUsers can produce these palettes with pick_palette() function.\n\nh2 &lt;- pick_palette(img)\nd2 &lt;- pick_palette(img)\nb2 &lt;- pick_palette(img)\nimage_combine(h2, d2, b2, ncol = 3)\n\n\n4.1.1 Defaults settings\n\nsev &lt;- \n  measure_disease(img = img,\n                  img_healthy = h,\n                  img_symptoms = d,\n                  img_background = b)\n\n\n\nsev$severity\n\n  healthy symptomatic\n1  85.309      14.691\n\n\n\n4.1.2 Filling lesions\n\nsev &lt;- \n  measure_disease(img = img,\n                  img_healthy = h,\n                  img_symptoms = d,\n                  img_background = b,\n                  show_contour = FALSE)\n\n\n\n\n\n4.1.3 Showing a mask\n\nsev &lt;- \n  measure_disease(img = img,\n                  img_healthy = h,\n                  img_symptoms = d,\n                  img_background = b,\n                  show_original = FALSE,\n                  col_lesions = \"brown\") # default is \"black\"\n\n\n\n\n\n4.1.4 Segmenting and analyzing lesions\nWhen using show_features = TRUE, the function analyzes the lesions and returns results such as number of lesions, area, perimeter, etc. With show_segmentation = TRUE, segmented lesions are shown.\n\nsev &lt;- \n  measure_disease(img = img,\n                  img_healthy = h,\n                  img_symptoms = d,\n                  img_background = b,\n                  show_features = TRUE,\n                  watershed = TRUE,\n                  show_segmentation = TRUE)\n\n\n\n# correct the measures (dpi = 150)\nsev_corrected &lt;- get_measures(sev, dpi = 150)"
  },
  {
    "objectID": "04_phytopathometry.html#segment-by-color",
    "href": "04_phytopathometry.html#segment-by-color",
    "title": "Phytopathometry",
    "section": "\n9.1 Segment by color",
    "text": "9.1 Segment by color\nWhen multiple leaves are present in an image, the measure_disease function returns the average severity of the leaves present in the image. To quantify the severity per leaf, the measure_disease_byl() function can be used.\nThis function computes the percentage of symptomatic leaf area using color palettes or RGB indices for each leaf (byl) of an image. This allows, for example, to process replicates of the same treatment and obtain the results of each replication with a single image. To do this, the sample sheets are first split using the object_split() function and then the measure_disease() function is applied to the sheet list.\n\nbyl &lt;- \n  measure_disease_byl(pattern = \"multiplas_02\",\n                      index = \"B\", # used to segment leaves from background\n                      img_healthy = \"soja_h\",\n                      img_symptoms = \"soja_s\",\n                      show_contour = FALSE,\n                      show_features = TRUE,\n                      col_lesions = \"red\",\n                      parallel = TRUE)\n\nImage processing using multiple sessions (6). Please wait.\n\nresults_byl &lt;- get_measures(byl)\n\nresults_byl$results |&gt; \n  head()\n\n           img leaf id       mx        my area perimeter radius_mean radius_min\n1 multiplas_02    1  1 171.2667  80.32549   62  40.97056     4.90362    1.09451\n2 multiplas_02    1  2 236.4953 102.94576  520 126.39697    13.72704    2.64672\n3 multiplas_02    1  3 135.8283 100.38182  100  36.55635     5.21944    3.54338\n4 multiplas_02    1  4 196.3157 128.99638 1196 209.65180    19.48381    5.27639\n5 multiplas_02    1  6 155.3493 129.39204  397 121.81118    10.88886    1.10118\n6 multiplas_02    1  8 219.5256 115.18590   39  26.31371     2.98820    0.95833\n  radius_max radius_sd diam_mean diam_min diam_max maj_axis min_axis   length\n1    8.89021   2.30936   9.80723  2.18902 17.78042  5.18036  1.54865 16.46903\n2   23.92081   5.14020  27.45408  5.29344 47.84162 13.16349  6.42927 43.98674\n3    6.87184   0.99468  10.43889  7.08676 13.74369  4.32261  3.08497 13.15289\n4   31.61094   7.09368  38.96762 10.55278 63.22188 17.41109 11.24782 60.57374\n5   19.01536   4.12090  21.77773  2.20237 38.03073  9.58203  6.60092 33.93652\n6    4.49092   0.90059   5.97640  1.91667  8.98185  2.37612  2.01511  8.22970\n     width\n1  5.75413\n2 22.97408\n3  8.67840\n4 41.21600\n5 24.09180\n6  6.02056"
  },
  {
    "objectID": "04_phytopathometry.html#segment-by-shape",
    "href": "04_phytopathometry.html#segment-by-shape",
    "title": "Phytopathometry",
    "section": "\n9.2 Segment by shape",
    "text": "9.2 Segment by shape\n\nimg &lt;- image_import(\"disease_shp.jpg\", plot = TRUE)\nbyl2 &lt;- \n  measure_disease_shp(img,\n                      filter = 10,\n                      ncol = 3,\n                      nrow = 3,\n                      index_lb = \"HUE2\",\n                      index_dh = \"NGRDI\",\n                      threshold = c(\"Otsu\", 0),\n                      plot = FALSE)\nplot(img)\nplot(byl2$shapefiles)\nplot_measures(byl2, measure = \"symptomatic\")"
  },
  {
    "objectID": "02_segment.html",
    "href": "02_segment.html",
    "title": "Segment objects",
    "section": "",
    "text": "setwd(\"E:/Desktop/UFSC/cursos/pliman_tut/imgs\")"
  },
  {
    "objectID": "02_segment.html#using-image-indexes",
    "href": "02_segment.html#using-image-indexes",
    "title": "Segment objects",
    "section": "\n5.1 Using image indexes",
    "text": "5.1 Using image indexes\nThe image_segment() function is used to segment images using image indices. In this example, we will use compare the B and NB index to segment the leaves.\n\nseg1 &lt;- \n  image_segment(img,\n                index = c(\"B, NB\"))"
  },
  {
    "objectID": "02_segment.html#using-k-means-algorithm",
    "href": "02_segment.html#using-k-means-algorithm",
    "title": "Segment objects",
    "section": "\n5.2 Using k-means algorithm",
    "text": "5.2 Using k-means algorithm\nTHe function image_segment_kmeans() segments image objects using clustering by the k-means clustering algorithm. Users need to declare the number of classes after object segmentation using the argument nclasses. By default, two classes are returned.\n\nseg2 &lt;- image_segment_kmeans(img, nclasses = 4)\n\n\n\nseg2 &lt;- image_segment_kmeans(img, nclasses = 2) # default\n\n\n\nseg2 &lt;- \n  image_segment_kmeans(img,\n                       nclasses = 2,\n                       invert = TRUE,\n                       filter = 5)"
  },
  {
    "objectID": "02_segment.html#using-a-mask",
    "href": "02_segment.html#using-a-mask",
    "title": "Segment objects",
    "section": "\n5.3 Using a mask",
    "text": "5.3 Using a mask\nBy using image_segment_mask() it is possible to segment an object using a mask.\n\nobjs &lt;- image_import(\"objects_300.jpg\", plot = TRUE)\nimage_segment_mask(objs,\n                   type = \"shadow\",\n                   size = 1171,\n                   shape = \"box\")\nimage_segment_mask(objs,\n                   size = 1171,\n                   rel_pos_y = 0.6,\n                   rel_pos_x = 0.08,\n                   shape = \"disc\")\n\n\n\n\n\n\n\n\n\nImage \n  colorMode    : Color \n  storage.mode : double \n  dim          : 2126 1535 3 \n  frames.total : 3 \n  frames.render: 1 \n\nimageData(object)[1:5,1:6,1]\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    1    1    1    1    1\n[2,]    1    1    1    1    1    1\n[3,]    1    1    1    1    1    1\n[4,]    1    1    1    1    1    1\n[5,]    1    1    1    1    1    1\n\n\n\n\n\n\n\nImage \n  colorMode    : Color \n  storage.mode : double \n  dim          : 2126 1535 3 \n  frames.total : 3 \n  frames.render: 1 \n\nimageData(object)[1:5,1:6,1]\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    1    1    1    1    1\n[2,]    1    1    1    1    1    1\n[3,]    1    1    1    1    1    1\n[4,]    1    1    1    1    1    1\n[5,]    1    1    1    1    1    1"
  },
  {
    "objectID": "02_segment.html#iterative-segmentation",
    "href": "02_segment.html#iterative-segmentation",
    "title": "Segment objects",
    "section": "\n6.1 Iterative segmentation",
    "text": "6.1 Iterative segmentation\nThe function image_segment_iter() provides an iterative image segmentation. Users can choose how many segmentation to perform, using the argument nseg. Note that the same results can be obtained with image_segment_iter() using an iterative section.\n\n# Only run iteratively\nimage_segment_iter(img, nseg = 1)"
  },
  {
    "objectID": "02_segment.html#point-click-and-segment",
    "href": "02_segment.html#point-click-and-segment",
    "title": "Segment objects",
    "section": "\n6.2 Point, click, and segment",
    "text": "6.2 Point, click, and segment\nimage_segment_manual() segments image objects ‘by hand’. The user will need to pick the perimeter of the object to be segmented. So, this only works in an interactive section.\n\nx11()\nseg3 &lt;- image_segment_manual(img)\nseg3 &lt;- image_segment_manual(img, resize = FALSE)\nseg3 &lt;- image_segment_manual(img, type = \"exclude\")"
  },
  {
    "objectID": "02_segment.html#shapefiles",
    "href": "02_segment.html#shapefiles",
    "title": "Segment objects",
    "section": "\n6.3 Shapefiles",
    "text": "6.3 Shapefiles\nimage_shp() creates a list of object coordinates given the desired number of rows and columns. It starts by selecting 4 points at the corners of objects of interest in the plot space. Then, given rows and cols, a grid is drawn and the objects’ coordinates are returned.\n\nx11()\nflax &lt;- image_import(\"shapefiles.jpg\", plot = TRUE)\nshps &lt;- image_shp(flax, rows = 3, cols = 10)\nstr(shps)\nlines(shps$bbox, col = \"red\", lwd = 5)\n\nobject_split_shp() splits the image objects into a list of objects considering the object coordinates computed with image_shp().\n\nleaves &lt;- object_split_shp(flax, rows = 3, cols = 5)\nimage_combine(leaves[1:2])"
  },
  {
    "objectID": "00_about.html",
    "href": "00_about.html",
    "title": "Useful info!",
    "section": "",
    "text": "1 Software and instalation\n Download do R\n Download do RStudio\n\n\n  \n\n\n\n\n\n\n2 Author\n\n\n\n\n\n3 Overview\n\n{pliman} (plant image analysis) is designed (but not limited) to analyze plant images, especially related to leaf and seed analysis. The package will help you to:\n\nMeasure the severity of foliar diseases;\nCount the number of injuries;\nObtain characteristics of the shape of the lesions;\nCount objects in an image;\nObtain characteristics of objects (area, perimeter, radius, circularity, eccentricity, solidity, elongation);\nGet the RGB values for each object in an image;\nGet the coordinates of objects;\nGet the outlines of objects;\nGet the convex hull;\nIsolate objects;\nPlot object measurements.\n\n4 Instalation\nInstall the released version of pliman from CRAN with:\n\ninstall.packages (\"pliman\")\n\nOr install the development version from GitHub\n\n# instalação do github\nif(!require(devtools)){\n  install.packages(\"devtools\")\n}\n\ninstall_github(\"TiagoOlivoto/pliman\")\n\n# Para instalar a vinheta HTML, use\ndevtools::install_github(\"TiagoOlivoto/pliman\", build_vignettes = TRUE)\n\nNote: If you are a Windows user, it is suggested to first download and install the latest version of Rtools. For the latest release notes on this development version, see the NEWS file.\n\n5 Citation\nTo cite the pliman package in your studies, please, use the following reference:\n\nOlivoto, Tiago. 2022. “Lights, Camera, Pliman! An R Package for Plant Image Analysis”. Methods in Ecology and Evolution 13(4): 789–98 doi: 10.1111/2041-210X.13803\n\n\n\ncitation(\"pliman\")\n\n\nPlease, support this project by citing it in your publications!\n\n  Olivoto T (2022). \"Lights, camera, pliman! An R package for plant\n  image analysis.\" _Methods in Ecology and Evolution_, *13*(4),\n  789-798. doi:10.1111/2041-210X.13803\n  &lt;https://doi.org/10.1111/2041-210X.13803&gt;.\n\nA BibTeX entry for LaTeX users is\n\n  @Article{,\n    title = {Lights, camera, pliman! An R package for plant image analysis},\n    author = {Tiago Olivoto},\n    year = {2022},\n    journal = {Methods in Ecology and Evolution},\n    volume = {13},\n    number = {4},\n    pages = {789-798},\n    doi = {10.1111/2041-210X.13803},\n  }\n\n\n\n6 Useful packages\nThe results generated by the pliman package are returned as data.frame objects, which allows future manipulation within R. Therefore, it is suggested that the following packages be installed.\n\nlibrary(tidyverse)  # data manipulation\nlibrary(metan)      # descriptive statistics / arrange graphics\nlibrary(pliman)     # image analysis\n\n\n7 How to reproduce\nFirst, donwload the .zip file that contains the static website.\n  Download the images and scripts \nThe folder img has the following structure.\n\n\nWarning: package 'fs' was built under R version 4.2.3\n\n\nE:/Desktop/UFSC/cursos/pliman_tut/imgs\n├── bean.jpg\n├── black.jpeg\n├── compound.jpg\n├── disease.jpeg\n├── disease_shp.jpg\n├── feijao_b.png\n├── feijao_h.png\n├── feijao_s.png\n├── flax.jpg\n├── flax1.jpg\n├── flax2.jpg\n├── flax3.jpg\n├── flax4.jpg\n├── flax5.jpg\n├── folhalin.png\n├── folhas.jpg\n├── fourier\n│   ├── changes.png\n│   ├── distance.png\n│   ├── img1.jpg\n│   ├── img2.jpg\n│   ├── img3.jpg\n│   ├── img4.jpg\n│   ├── img5.jpg\n│   ├── img6.jpg\n│   ├── img7.jpg\n│   ├── img8.jpg\n│   └── img9.jpg\n├── fundolin.png\n├── fungo.jpeg\n├── gif_severity.gif\n├── grains.JPG\n├── green.jpg\n├── holes.jpg\n├── imgs\n│   ├── img_exported.jpg\n│   └── test\n├── img_exported.jpg\n├── L1_1.jpg\n├── L1_2.jpg\n├── L2_1.jpg\n├── L2_2.jpg\n├── L3_1.jpg\n├── L3_2.jpg\n├── L3_3.jpg\n├── L4_1.jpg\n├── L4_2.jpg\n├── L4_3.jpg\n├── L5_1.jpg\n├── L5_2.jpg\n├── leaf1.jpg\n├── leaf2.jpg\n├── leaf3.jpg\n├── leaf4.jpg\n├── leaf5.jpg\n├── linhaca\n│   ├── A10_90_1.jpg\n│   ├── A10_90_2.jpg\n│   ├── A10_90_3.jpg\n│   ├── A11_98_1.jpg\n│   ├── A11_98_2.jpg\n│   ├── A11_98_3.jpg\n│   ├── A12_105_1.jpg\n│   ├── A12_105_2.jpg\n│   ├── A12_105_3.jpg\n│   ├── A1_28_1.jpg\n│   ├── A1_28_2.jpg\n│   ├── A1_28_3.jpg\n│   ├── A2_32_1.jpg\n│   ├── A2_32_2.jpg\n│   ├── A2_32_3.jpg\n│   ├── A3_42_1.jpg\n│   ├── A3_42_2.jpg\n│   ├── A3_42_3.jpg\n│   ├── A4_46_1.jpg\n│   ├── A4_46_2.jpg\n│   ├── A4_46_3.jpg\n│   ├── A5_55_1.jpg\n│   ├── A5_55_2.jpg\n│   ├── A5_55_3.jpg\n│   ├── A6_63_1.jpg\n│   ├── A6_63_2.jpg\n│   ├── A6_63_3.jpg\n│   ├── A7_70_1.jpg\n│   ├── A7_70_2.jpg\n│   ├── A7_70_3.jpg\n│   ├── A8_76_1.jpg\n│   ├── A8_76_2.jpg\n│   ├── A8_76_3.jpg\n│   ├── A9_83_1.jpg\n│   ├── A9_83_2.jpg\n│   ├── A9_83_3.jpg\n│   ├── proc\n│   └── res\n├── lista\n│   ├── img_sb_50_1.jpg\n│   └── img_sb_50_2.jpg\n├── lista_exportada\n│   ├── img_exported.jpg\n│   ├── img_sb_50_1.jpg\n│   ├── img_sb_50_10.jpg\n│   ├── img_sb_50_11.jpg\n│   ├── img_sb_50_12.jpg\n│   ├── img_sb_50_13.jpg\n│   ├── img_sb_50_2.jpg\n│   ├── img_sb_50_3.jpg\n│   ├── img_sb_50_4.jpg\n│   ├── img_sb_50_5.jpg\n│   ├── img_sb_50_6.jpg\n│   ├── img_sb_50_7.jpg\n│   ├── img_sb_50_8.jpg\n│   └── img_sb_50_9.jpg\n├── manipula\n│   ├── 20220819_140351.jpg\n│   ├── 20220819_140836.jpg\n│   ├── 20220819_141224.jpg\n│   ├── 20220819_141521.jpg\n│   └── renomeadas\n├── mosaic.jpg\n├── multiplas_01.jpeg\n├── multiplas_02.jpeg\n├── multiplas_03.jpeg\n├── multiplas_04.jpeg\n├── multiplas_05.jpg\n├── objects_300.jpg\n├── proc\n│   ├── proc_soy_1.jpg\n│   ├── proc_soy_10.jpg\n│   ├── proc_soy_11.jpg\n│   ├── proc_soy_12.jpg\n│   ├── proc_soy_13.jpg\n│   ├── proc_soy_14.jpg\n│   ├── proc_soy_15.jpg\n│   ├── proc_soy_16.jpg\n│   ├── proc_soy_17.jpg\n│   ├── proc_soy_18.jpg\n│   ├── proc_soy_19.jpg\n│   ├── proc_soy_2.jpg\n│   ├── proc_soy_20.jpg\n│   ├── proc_soy_21.jpg\n│   ├── proc_soy_22.jpg\n│   ├── proc_soy_23.jpg\n│   ├── proc_soy_24.jpg\n│   ├── proc_soy_25.jpg\n│   ├── proc_soy_26.jpg\n│   ├── proc_soy_27.jpg\n│   ├── proc_soy_28.jpg\n│   ├── proc_soy_29.jpg\n│   ├── proc_soy_3.jpg\n│   ├── proc_soy_30.jpg\n│   ├── proc_soy_31.jpg\n│   ├── proc_soy_32.jpg\n│   ├── proc_soy_33.jpg\n│   ├── proc_soy_34.jpg\n│   ├── proc_soy_35.jpg\n│   ├── proc_soy_36.jpg\n│   ├── proc_soy_37.jpg\n│   ├── proc_soy_38.jpg\n│   ├── proc_soy_39.jpg\n│   ├── proc_soy_4.jpg\n│   ├── proc_soy_40.jpg\n│   ├── proc_soy_41.jpg\n│   ├── proc_soy_42.jpg\n│   ├── proc_soy_43.jpg\n│   ├── proc_soy_44.jpg\n│   ├── proc_soy_45.jpg\n│   ├── proc_soy_46.jpg\n│   ├── proc_soy_47.jpg\n│   ├── proc_soy_48.jpg\n│   ├── proc_soy_49.jpg\n│   ├── proc_soy_5.jpg\n│   ├── proc_soy_50.jpg\n│   ├── proc_soy_6.jpg\n│   ├── proc_soy_7.jpg\n│   ├── proc_soy_8.jpg\n│   └── proc_soy_9.jpg\n├── ref_leaves.jpg\n├── resultado.xlsx\n├── Rplots.pdf\n├── rule.jpg\n├── samples.png\n├── scripts_pliman_rmd_files\n│   └── figure-html\n├── sev_back.png\n├── sev_disease.png\n├── sev_healthy.png\n├── shapefiles.jpg\n├── simple.jpg\n├── site.png\n├── soja\n│   ├── img_sb_50_1.jpg\n│   ├── img_sb_50_10.jpg\n│   ├── img_sb_50_11.jpg\n│   ├── img_sb_50_12.jpg\n│   ├── img_sb_50_13.jpg\n│   ├── img_sb_50_2.jpg\n│   ├── img_sb_50_3.jpg\n│   ├── img_sb_50_4.jpg\n│   ├── img_sb_50_5.jpg\n│   ├── img_sb_50_6.jpg\n│   ├── img_sb_50_7.jpg\n│   ├── img_sb_50_8.jpg\n│   └── img_sb_50_9.jpg\n├── soja_b.png\n├── soja_h.png\n├── soja_s.png\n├── soy_1.jpg\n├── soy_10.jpg\n├── soy_11.jpg\n├── soy_12.jpg\n├── soy_13.jpg\n├── soy_14.jpg\n├── soy_15.jpg\n├── soy_16.jpg\n├── soy_17.jpg\n├── soy_18.jpg\n├── soy_19.jpg\n├── soy_2.jpg\n├── soy_20.jpg\n├── soy_21.jpg\n├── soy_22.jpg\n├── soy_23.jpg\n├── soy_24.jpg\n├── soy_25.jpg\n├── soy_26.jpg\n├── soy_27.jpg\n├── soy_28.jpg\n├── soy_29.jpg\n├── soy_3.jpg\n├── soy_30.jpg\n├── soy_31.jpg\n├── soy_32.jpg\n├── soy_33.jpg\n├── soy_34.jpg\n├── soy_35.jpg\n├── soy_36.jpg\n├── soy_37.jpg\n├── soy_38.jpg\n├── soy_39.jpg\n├── soy_4.jpg\n├── soy_40.jpg\n├── soy_41.jpg\n├── soy_42.jpg\n├── soy_43.jpg\n├── soy_44.jpg\n├── soy_45.jpg\n├── soy_46.jpg\n├── soy_47.jpg\n├── soy_48.jpg\n├── soy_49.jpg\n├── soy_5.jpg\n├── soy_50.jpg\n├── soy_6.jpg\n├── soy_7.jpg\n├── soy_8.jpg\n├── soy_9.jpg\n├── TRAT1_1.jpg\n├── TRAT1_2.jpg\n├── TRAT1_3.jpg\n├── TRAT1_4.jpg\n├── TRAT2_1.jpg\n├── TRAT2_2.jpg\n├── TRAT2_3.jpg\n├── TRAT2_4.jpg\n├── TRAT3_1.jpg\n├── TRAT3_2.jpg\n├── TRAT3_3.jpg\n├── TRAT3_4.jpg\n├── TRAT4_1.jpg\n├── TRAT4_2.jpg\n├── TRAT4_3.jpg\n├── TRAT4_4.jpg\n├── vicia.jpg\n├── videira.png\n├── videira_b.png\n├── videira_d.png\n└── videira_h.png\n\n\nThe html material (_site/index.html) will give access to the site. Within it, it will be possible to visualize all the examples, with codes and outputs. To reproduce the material, just use the *.qmd files.\nFor rendering, it is suggested that the folder imgs be set as the default directory. In my case, I set the directory using the following command.\n\n# change according to your folder\nsetwd(\"E:/Desktop/UFSC/cursos/pliman_tut/imgs\")\n\n\n\n8 Slides\nSee the slides here\n\n\n\n\n\n9 License\nThis content is licensed under a CC BY-NC-SA 4.0. The readable license summary states that you have the right to:\n Share — copy and redistribute material in any medium or format\nAdapt — remix, transform, and build upon material\nAttribution — You must give appropriate credit, provide a link to the license and indicate if changes have been made. You must do so under any reasonable circumstances, but in no way that suggests that the licensor endorses you or your use.\nAccording to the following terms\n\nNon-Commercial — You may not use the material for commercial purposes.\nShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.\nNo Additional Restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license allows."
  },
  {
    "objectID": "01_manipulate.html",
    "href": "01_manipulate.html",
    "title": "Import and manipulate",
    "section": "",
    "text": "1 Directory\n\nsetwd(\"E:/Desktop/UFSC/cursos/pliman_tut/imgs\")\n\n\n2 File manipulation\n\nlibrary(pliman)\nlibrary(tidyverse)\nlibrary(patchwork)\n# set_wd_here(\"imgs\")\nlist.files(pattern = \"2022\", path = \"manipula\")\n## [1] \"20220819_140351.jpg\" \"20220819_140836.jpg\" \"20220819_141224.jpg\"\n## [4] \"20220819_141521.jpg\"\n\n# name vector\nnomes &lt;- c(\"T1_R1\", \"T1_R2\", \"T2_R1\", \"T2_R2\")\n\n# rename the files\nmanipulate_files(pattern = \"2022\",\n                 name = nomes,\n                 save_to = \"manipula/renomeadas\",\n                 dir = \"manipula\")\n\n\n3 Import images\n\nimg &lt;- image_import(\"folhas.jpg\")\n\nTo import a list of images, use a vector of image names, or the pattern argument. In the latter, all images that match the pattern name are imported into a list.\n\nimg_list1 &lt;- image_import(c(\"img_sb_50_1.jpg\", \"img_sb_50_2.jpg\"), path = \"soja\")\nimg_list2 &lt;- image_import(pattern = \"img_sb_\", path = \"soja\")\nstr(img_list2)\n\nList of 13\n $ img_sb_50_1.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.365 0.361 0.361 0.349 0.365 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_10.jpg:Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.42 0.408 0.416 0.416 0.416 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_11.jpg:Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.388 0.38 0.384 0.38 0.369 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_12.jpg:Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.38 0.376 0.392 0.384 0.392 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_13.jpg:Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.392 0.392 0.412 0.384 0.4 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_2.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.376 0.384 0.392 0.388 0.396 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_3.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.369 0.376 0.361 0.361 0.365 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_4.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.4 0.408 0.404 0.396 0.392 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_5.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.396 0.404 0.396 0.396 0.388 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_6.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.4 0.38 0.396 0.384 0.388 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_7.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.349 0.361 0.365 0.365 0.373 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_8.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.361 0.373 0.376 0.388 0.384 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n $ img_sb_50_9.jpg :Formal class 'Image' [package \"EBImage\"] with 2 slots\n  .. ..@ .Data    : num [1:816, 1:612, 1:3] 0.373 0.365 0.373 0.384 0.392 ...\n  .. ..@ colormode: int 2\n  .. ..$ dim: int [1:3] 816 612 3\n\n\n\n4 Displaying imagens\nIndividual images are displayed with plot(). To combine images, the image_combine() function is used. Users can enter a comma-separated list of objects or a list of objects of the Image class.\n\n# Imagens individuais\nplot(img)\n\n\n\n\n\n# Combine imagens\nimage_combine(img_list1)\n\n\n\n\npliman provides a set of image_*() functions to perform image manipulation and transformation of unique images or an image list based on EBImage package.\n\n5 Resize an image\nSometimes resizing high-resolution images is necessary to reduce computational effort and processing time. The image_resize() function is used to resize an image. The rel_size argument can be used to resize the image by relative size. For example, setting rel_size = 50 for an image of width 1280 x 720, the new image will have a size of 640 x 360.\n\nimage_dimension(img)\n\n\n----------------------\nImage dimension\n----------------------\nWidth :  783 \nHeight:  1005 \n\nimg_resized &lt;- image_resize(img, rel_size = 50)\nimage_dimension(img_resized)\n\n\n----------------------\nImage dimension\n----------------------\nWidth :  392 \nHeight:  502 \n\n\n\n6 Image resolution (DPI)\nThe dpi() function executes an interactive function to calculate the image resolution given a known distance entered by the user. To calculate the image resolution (dpi), the user must use the left mouse button to create a line of known distance. This can be done, for example, using a model with known distance, as follows.\n\n#  this only works in an interactive section\nrule &lt;- image_import(\"rule.jpg\", plot = TRUE)\nx11()\n(imgres &lt;- dpi(rule))\n\nrule2 &lt;- \n  image_crop(rule,\n             width = 130:1390,\n             height = 582:1487,\n             plot = TRUE)\n\nanalyze_objects(rule2,\n                watershed = FALSE,\n                marker = \"area\",\n                contour_col = \"blue\",\n                contour_size = 8) |&gt; \n  get_measures(dpi = 518) |&gt; \n  plot_measures(measure = \"area\", vjust = -100, size = 2)\n\n\n7 Align an image\nTo construct shapefiles with image_shp() the image objects need to be aligned along the x/y axis. image_align() can be used to provide such alignment. Users will need to draw a line along the y axis that corresponds to the alignment of the objects (e.g., field plots). By default, the aligment will be to the vertical, which means that if the drawed line have an angle &lt; 90º parallel to the x axis, the rotation angle wil be negative (anticlocwise rotation). If the drawed line have an angle &gt; 90º along the x axis, the rotation angle wil be positive (clocwise rotation). If the aligment is horizontal, the image will be rotated to align the drawed line paralell to the x axis assuming the shortest angle (left or right rotation if the angle is &lt; 90º or &gt; 90º, respectively)\n\nshp &lt;- image_import(\"shapefiles.jpg\")\nshp_aligned &lt;- image_align(shp)\n\n\n8 Filter, blur, contrast, dilatation, erosion, opening, and closing\n\nimg_filter &lt;- image_filter(img)\nimg_blur &lt;- image_blur(img)\nimg_contrast &lt;- image_contrast(img)\nimg_dilatation &lt;- image_dilate(img)\nimg_erosion &lt;- image_erode(img)\nimg_opening &lt;- image_opening(img)\nimg_closing &lt;- image_closing(img)\nimage_combine(img,\n              img_filter,\n              img_blur,\n              img_contrast,\n              img_dilatation,\n              img_erosion,\n              img_opening,\n              img_closing,\n              ncol = 4)\n\n\n\n\n\n9 Apply a function to images\n\napply_fun_to_imgs(pattern = \"img_\",\n                  fun = image_autocrop,\n                  dir_processed = \"lista_exportada\")\n\nProcessing image img_exported.jpg |==============================| 100% 00:00:00 \n\n\n\n10 Export\nTo export images to the current directory, use the image_export() function. If an image list is exported, the images will be saved considering the name and extension present in the list. If no extension is present, images will be saved as *.jpg files.\n\nimage_export(img, \"imgs/img_exported.jpg\")\n# or a subfolder\nimage_export(img, \"imgs/test/img_exported.jpg\")\n\nimage_export(img_list1, subfolder = \"lista\")"
  },
  {
    "objectID": "03_analyze.html",
    "href": "03_analyze.html",
    "title": "Analyze objects",
    "section": "",
    "text": "setwd(\"E:/Desktop/UFSC/cursos/pliman_tut/imgs\")"
  },
  {
    "objectID": "03_analyze.html#area",
    "href": "03_analyze.html#area",
    "title": "Analyze objects",
    "section": "\n2.1 Area",
    "text": "2.1 Area\nThe area of a shape is calculated using Shoelace’s formula (Lee and Lim, 2017)5, as follows\n\\[\nA=\\frac{1}{2}\\left |\\sum_{i=1}^{n}\\left(x_{i} y_{i+1}-x_{i+1}y_{i}\\right)\\right|\n\\]\n\npoly_area(cont)\n\n [1] 18352.5 36372.0 37283.0 16610.5  5077.0 30713.5 19633.0  6659.0  9035.0\n[10]  3083.5 12284.5  8285.0  1518.5  1878.0  1271.5  9692.0  3306.5  8433.5\n[19]  2952.0 16263.0 12589.0  1865.5  1726.0"
  },
  {
    "objectID": "03_analyze.html#perimeter",
    "href": "03_analyze.html#perimeter",
    "title": "Analyze objects",
    "section": "\n2.2 Perimeter",
    "text": "2.2 Perimeter\nThe perimeter is calculated as the sum of the Euclidean distance between all points on a shape. Distances can be obtained with poly_distpts().\n\npoly_perimeter(cont)\n\n        1         2         3         4         5         6         7        10 \n 615.2569 1125.0874  797.8082  552.3574  386.2914  897.2102  604.4701  412.7056 \n       11        14        15        16        17        18        19        20 \n 453.4163  284.3797  502.7716  469.5584  160.4386  285.4508  156.2965  412.1026 \n       21        22        23        24        25        26        27 \n 256.8650  365.7279  301.3087  538.4701  479.2742  211.8944  548.2548 \n\n# perimeter of a circle with radius 2\ncircle &lt;- draw_circle(radius = 2, plot = FALSE)\npoly_perimeter(circle)\n\n[1] 12.56635\n\n# check the result\n2*pi*2\n\n[1] 12.56637"
  },
  {
    "objectID": "03_analyze.html#radius",
    "href": "03_analyze.html#radius",
    "title": "Analyze objects",
    "section": "\n2.3 Radius",
    "text": "2.3 Radius\nThe radius of a pixel on the object’s contour is calculated as its distance from the object’s centroid(also called ‘center of mass’). These distances can be obtained with poly_centdist().\n\ndist &lt;- poly_centdist(cont)\n\n# stats for radius\nmean_list(dist)\n\n        1         2         3         4         5         6         7        10 \n 81.50472 107.15072 111.67757  75.92128  48.48228 112.97916  82.68263  53.51156 \n       11        14        15        16        17        18        19        20 \n 56.72946  36.54740  64.67529  61.75205  22.48669  33.83886  21.25721  57.39115 \n       21        22        23        24        25        26        27 \n 34.56566  52.56715  38.06452  73.40734  65.81308  28.06548  67.26094 \n\nmin_list(dist)\n\n        1         2         3         4         5         6         7        10 \n56.365931 62.460726 79.800528 55.452805 21.232635 48.004837 53.638969 25.979106 \n       11        14        15        16        17        18        19        20 \n34.823777 15.440760 43.867424 29.407891 15.553085  5.815242 11.841794 42.995237 \n       21        22        23        24        25        26        27 \n23.217347 44.807718 13.925495 59.848727 47.836671 16.415385  3.438458 \n\nmax_list(dist)\n\n        1         2         3         4         5         6         7        10 \n126.82821 152.42898 166.37215 115.03892  84.48600 192.29568 127.78141  91.08601 \n       11        14        15        16        17        18        19        20 \n 88.38574  62.81868  95.99267 106.86452  33.31437  62.59528  33.27942  85.25620 \n       21        22        23        24        25        26        27 \n 54.26327  64.41345  67.61794 104.72813  98.71630  47.72001 134.03105 \n\nsd_list(dist)\n\n        1         2         3         4         5         6         7        10 \n17.425062 18.421426 24.407052 14.837653 18.090150 41.426392 21.177024 19.809781 \n       11        14        15        16        17        18        19        20 \n13.522420 13.821949 12.949648 23.157277  5.360341 15.964780  6.161850 12.086296 \n       21        22        23        24        25        26        27 \n 8.886554  5.709767 15.304076  9.980561 12.689383  8.956172 38.480834 \n\n# average radius of above circle\npoly_centdist(circle) |&gt; mean_list()\n\n[1] 1.999998"
  },
  {
    "objectID": "03_analyze.html#length-and-width",
    "href": "03_analyze.html#length-and-width",
    "title": "Analyze objects",
    "section": "\n2.4 Length and width",
    "text": "2.4 Length and width\nThe length and width of an object are calculated with poly_lw(), as the difference between the maximum and minimum of the x and y coordinates after the object has been aligned with poly_align().\n\npoly_lw(cont)\n\n         length     width\n [1,] 238.54100 125.05197\n [2,] 280.55220 237.69204\n [3,] 315.47889 166.64659\n [4,] 209.33606 123.39163\n [5,] 168.01252  54.02002\n [6,] 375.58661 131.13737\n [7,] 249.45384 116.64014\n [8,] 179.84217  62.94321\n [9,] 152.34622 114.49558\n[10,] 124.87025  39.06435\n[11,] 166.54470 126.32871\n[12,] 208.31970  68.91857\n[13,]  66.15298  32.52419\n[14,] 123.16969  30.24387\n[15,]  66.09709  28.40237\n[16,] 164.06833  90.09544\n[17,] 102.73052  50.34951\n[18,] 100.45299  98.53530\n[19,] 133.47743  37.65555\n[20,] 180.69778 135.88876\n[21,] 176.71212 111.21299\n[22,]  89.00219  36.02323\n[23,] 266.25888  10.45654"
  },
  {
    "objectID": "03_analyze.html#circularity-eccentricity-diameter-and-elongation",
    "href": "03_analyze.html#circularity-eccentricity-diameter-and-elongation",
    "title": "Analyze objects",
    "section": "\n2.5 Circularity, eccentricity, diameter, and elongation",
    "text": "2.5 Circularity, eccentricity, diameter, and elongation\nCircularity(Montero et al. 2009)6 is also called shape compactness, or measure of roundness of an object. It is given by \\(C = P^2 / A\\), where \\(P\\) is the perimeter and \\(A\\) is the area of the object.\n\npoly_circularity(cont)\n\n        1         2         3         4         5         6         7        10 \n 20.62613  34.80209  17.07207  18.36782  29.39158  26.20952  18.61071  25.57831 \n       11        14        15        16        17        18        19        20 \n 22.75444  26.22728  20.57710  26.61257  16.95130  43.38773  19.21241  17.52255 \n       21        22        23        24        25        26        27 \n 19.95452  15.86019  30.75437  17.82882  18.24638  24.06822 174.15027 \n\n\nAs the above measurement depends on the scale, normalized roundness can be used. In this case, a perfect circle is assumed to have a circularity equal to 1. This measure is invariant under translation, rotation and scale transformations, given \\(Cn = P^2 / 4 \\pi A\\)\n\npoly_circularity_norm(cont)\n\n        1         2         3         4         5         6         7        10 \n0.6092451 0.3610809 0.7360778 0.6841513 0.4275500 0.4794582 0.6752224 0.4912902 \n       11        14        15        16        17        18        19        20 \n0.5522602 0.4791335 0.6106970 0.4721968 0.7413221 0.2896296 0.6540756 0.7171542 \n       21        22        23        24        25        26        27 \n0.6297505 0.7923216 0.4086044 0.7048347 0.6887047 0.5221148 0.0721582 \n\n# normalized circularity for different shapes\ndraw_square(plot =FALSE) |&gt; poly_circularity_norm()\n\n[1] 1.396263\n\ndraw_circle(plot=FALSE) |&gt; poly_circularity_norm()\n\n[1] 0.9999967\n\n\npoly_circularity_haralick() calculates the Circularity of Haralick, CH (Haralick, 1974)7. The method is based on calculating all Euclidean distances from the object’s centroid to each contour pixel. With this set of distances, the mean(\\(m\\)) and the standard deviation(\\(s\\)) are calculated. These statistical parameters are used in a ratio that calculates CH as $CH = m/ sd $.\n\npoly_circularity_haralick(cont)\n\n       1        2        3        4        5        6        7       10 \n4.677442 5.816635 4.575627 5.116798 2.680038 2.727227 3.904355 2.701270 \n      11       14       15       16       17       18       19       20 \n4.195215 2.644156 4.994367 2.666637 4.195010 2.119594 3.449810 4.748449 \n      21       22       23       24       25       26       27 \n3.889658 9.206531 2.487214 7.355031 5.186468 3.133647 1.747908 \n\n\npoly_convexity() Calculates the convexity of a shape using a ratio of the perimeter of the convex hull to the perimeter of the polygon.\n\npoly_convexity(cont)\n\n        1         2         3         4         5         6         7        10 \n0.8967601 0.6876980 0.9192591 0.9132441 0.8298061 0.8645018 0.8757106 0.9226473 \n       11        14        15        16        17        18        19        20 \n0.8410503 0.9023328 0.8468413 0.9133223 0.9154601 0.6425806 0.9193294 0.9192070 \n       21        22        23        24        25        26        27 \n0.8967441 0.8459495 0.9009212 0.9076033 0.8508448 0.7493671 0.7361697 \n\n\npoly_eccentricity() Calculates the eccentricity of a shape using the ratio of the eigenvalues(coordinate inertia axes).\n\npoly_eccentricity(cont)\n\n             [,1]\n [1,] 0.346560699\n [2,] 0.844858938\n [3,] 0.401595451\n [4,] 0.431419527\n [5,] 0.132562754\n [6,] 0.156699400\n [7,] 0.322626716\n [8,] 0.149181272\n [9,] 0.543013592\n[10,] 0.142622157\n[11,] 0.608127299\n[12,] 0.127298521\n[13,] 0.379315768\n[14,] 0.069374529\n[15,] 0.275223477\n[16,] 0.414141956\n[17,] 0.313023030\n[18,] 0.960354914\n[19,] 0.109866568\n[20,] 0.648373662\n[21,] 0.456904377\n[22,] 0.190833679\n[23,] 0.002065428\n\n\npoly_elongation() Calculates the elongation of an object as 1 - width / length\n\npoly_elongation(cont)\n\n            [,1]\n [1,] 0.47576322\n [2,] 0.15277071\n [3,] 0.47176628\n [4,] 0.41055721\n [5,] 0.67847621\n [6,] 0.65084654\n [7,] 0.53241794\n [8,] 0.65000859\n [9,] 0.24845148\n[10,] 0.68716047\n[11,] 0.24147263\n[12,] 0.66916922\n[13,] 0.50834888\n[14,] 0.75445361\n[15,] 0.57029316\n[16,] 0.45086636\n[17,] 0.50988754\n[18,] 0.01909042\n[19,] 0.71788823\n[20,] 0.24797772\n[21,] 0.37065445\n[22,] 0.59525454\n[23,] 0.96072791\n\n\npoly_caliper() Calculates the gauge(also called Feret’s diameter).\n\npoly_caliper(cont)\n\n        1         2         3         4         5         6         7        10 \n235.68835 284.39585 314.63630 205.34118 160.11246 372.48490 249.28097 179.69418 \n       11        14        15        16        17        18        19        20 \n154.98387 124.78782 167.69317 207.57649  66.18912 123.32883  66.09841 164.24677 \n       21        22        23        24        25        26        27 \n102.78619 128.03515 133.37541 185.60711 177.11578  89.04493 266.18790 \n\n\nUsers can use the poly_measures() function to calculate most object measurements in a single call.\n\nmeasures &lt;- poly_measures(cont) |&gt; round_cols()\nt(measures)\n\n                            1        2        3        4       5        6\nid                       1.00     2.00     3.00     4.00    5.00     6.00\nx                      473.08   809.08   244.59   612.07  375.16   104.34\ny                      144.40   168.44   194.72   152.34  155.65   440.98\narea                 18352.50 36372.00 37283.00 16610.50 5077.00 30713.50\narea_ch              19538.50 45891.00 37696.50 17423.00 5670.50 32710.50\nperimeter              615.26  1125.09   797.81   552.36  386.29   897.21\nradius_mean             81.50   107.15   111.68    75.92   48.48   112.98\nradius_min              56.37    62.46    79.80    55.45   21.23    48.00\nradius_max             126.83   152.43   166.37   115.04   84.49   192.30\nradius_sd               17.43    18.42    24.41    14.84   18.09    41.43\nradius_ratio             2.25     2.44     2.08     2.07    3.98     4.01\ndiam_mean              163.01   214.30   223.36   151.84   96.96   225.96\ndiam_min               112.73   124.92   159.60   110.91   42.47    96.01\ndiam_max               253.66   304.86   332.74   230.08  168.97   384.59\ncaliper                238.54   280.55   315.48   209.34  168.01   375.59\nlength                 238.54   280.55   315.48   209.34  168.01   375.59\nwidth                  125.05   237.69   166.65   123.39   54.02   131.14\nsolidity                 0.94     0.79     0.99     0.95    0.90     0.94\nconvexity                0.90     0.69     0.92     0.91    0.83     0.86\nelongation               0.48     0.15     0.47     0.41    0.68     0.65\ncircularity             20.63    34.80    17.07    18.37   29.39    26.21\ncircularity_haralick     4.68     5.82     4.58     5.12    2.68     2.73\ncircularity_norm         0.61     0.36     0.74     0.68    0.43     0.48\neccentricity             0.35     0.84     0.40     0.43    0.13     0.16\npcv                      1.26     2.84     0.43     0.94    1.64     0.82\n                            7      10       11      14       15      16      17\nid                       7.00    8.00     9.00   10.00    11.00   12.00   13.00\nx                      929.08  341.49   529.46  632.11   773.02  446.42  568.82\ny                      375.55  375.53   335.35  405.31   430.98  518.10  474.33\narea                 19633.00 6659.00  9035.00 3083.50 12284.50 8285.00 1518.50\narea_ch              20110.50 7117.00 10330.00 3218.50 13343.50 8811.00 1553.00\nperimeter              604.47  412.71   453.42  284.38   502.77  469.56  160.44\nradius_mean             82.68   53.51    56.73   36.55    64.68   61.75   22.49\nradius_min              53.64   25.98    34.82   15.44    43.87   29.41   15.55\nradius_max             127.78   91.09    88.39   62.82    95.99  106.86   33.31\nradius_sd               21.18   19.81    13.52   13.82    12.95   23.16    5.36\nradius_ratio             2.38    3.51     2.54    4.07     2.19    3.63    2.14\ndiam_mean              165.37  107.02   113.46   73.09   129.35  123.50   44.97\ndiam_min               107.28   51.96    69.65   30.88    87.73   58.82   31.11\ndiam_max               255.56  182.17   176.77  125.64   191.99  213.73   66.63\ncaliper                249.45  179.84   152.35  124.87   166.54  208.32   66.15\nlength                 249.45  179.84   152.35  124.87   166.54  208.32   66.15\nwidth                  116.64   62.94   114.50   39.06   126.33   68.92   32.52\nsolidity                 0.98    0.94     0.87    0.96     0.92    0.94    0.98\nconvexity                0.88    0.92     0.84    0.90     0.85    0.91    0.92\nelongation               0.53    0.65     0.25    0.69     0.24    0.67    0.51\ncircularity             18.61   25.58    22.75   26.23    20.58   26.61   16.95\ncircularity_haralick     3.90    2.70     4.20    2.64     4.99    2.67    4.20\ncircularity_norm         0.68    0.49     0.55    0.48     0.61    0.47    0.74\neccentricity             0.32    0.15     0.54    0.14     0.61    0.13    0.38\npcv                      0.85    1.15     1.53    1.75     1.36    1.07    3.13\n                          18      19      20      21      22      23       24\nid                     14.00   15.00   16.00   17.00   18.00   19.00    20.00\nx                     305.39  633.31  858.65  751.61  536.84  654.67   199.12\ny                     534.70  510.59  557.43  555.64  588.83  630.47   665.41\narea                 1878.00 1271.50 9692.00 3306.50 8433.50 2952.00 16263.00\narea_ch              2332.00 1315.00 9969.00 3531.50 8529.50 3202.00 17237.00\nperimeter             285.45  156.30  412.10  256.87  365.73  301.31   538.47\nradius_mean            33.84   21.26   57.39   34.57   52.57   38.06    73.41\nradius_min              5.82   11.84   43.00   23.22   44.81   13.93    59.85\nradius_max             62.60   33.28   85.26   54.26   64.41   67.62   104.73\nradius_sd              15.96    6.16   12.09    8.89    5.71   15.30     9.98\nradius_ratio           10.76    2.81    1.98    2.34    1.44    4.86     1.75\ndiam_mean              67.68   42.51  114.78   69.13  105.13   76.13   146.81\ndiam_min               11.63   23.68   85.99   46.43   89.62   27.85   119.70\ndiam_max              125.19   66.56  170.51  108.53  128.83  135.24   209.46\ncaliper               123.17   66.10  164.07  102.73  100.45  133.48   180.70\nlength                123.17   66.10  164.07  102.73  100.45  133.48   180.70\nwidth                  30.24   28.40   90.10   50.35   98.54   37.66   135.89\nsolidity                0.81    0.97    0.97    0.94    0.99    0.92     0.94\nconvexity               0.64    0.92    0.92    0.90    0.85    0.90     0.91\nelongation              0.75    0.57    0.45    0.51    0.02    0.72     0.25\ncircularity            43.39   19.21   17.52   19.95   15.86   30.75    17.83\ncircularity_haralick    2.12    3.45    4.75    3.89    9.21    2.49     7.36\ncircularity_norm        0.29    0.65    0.72    0.63    0.79    0.41     0.70\neccentricity            0.07    0.28    0.41    0.31    0.96    0.11     0.65\npcv                     2.24    3.12    1.12    1.99    1.10    1.71     1.20\n                           25      26      27\nid                      21.00   22.00   23.00\nx                      767.38  313.05  428.12\ny                      675.03  656.60  696.30\narea                 12589.00 1865.50 1726.00\narea_ch              13171.50 2076.00 2079.00\nperimeter              479.27  211.89  548.25\nradius_mean             65.81   28.07   67.26\nradius_min              47.84   16.42    3.44\nradius_max              98.72   47.72  134.03\nradius_sd               12.69    8.96   38.48\nradius_ratio             2.06    2.91   38.98\ndiam_mean              131.63   56.13  134.52\ndiam_min                95.67   32.83    6.88\ndiam_max               197.43   95.44  268.06\ncaliper                176.71   89.00  266.26\nlength                 176.71   89.00  266.26\nwidth                  111.21   36.02   10.46\nsolidity                 0.96    0.90    0.83\nconvexity                0.85    0.75    0.74\nelongation               0.37    0.60    0.96\ncircularity             18.25   24.07  174.15\ncircularity_haralick     5.19    3.13    1.75\ncircularity_norm         0.69    0.52    0.07\neccentricity             0.46    0.19    0.00\npcv                      1.03    2.45    0.68\n\n\nIf the image resolution is known, the measurements can be corrected with get_measures(). Image resolution can be obtained using a known distance in the image. In the example, the white square has a side of 5 cm. So using dpi() the resolution can be obtained. In this case, the dpi is ~50.\n\ncolor_measures &lt;- get_measures(measures, dpi = 50)\nt(color_measures)\n\n                             1         2         3         4         5\nid                     1.00000   2.00000   3.00000   4.00000   5.00000\nx                    473.08000 809.08000 244.59000 612.07000 375.16000\ny                    144.40000 168.44000 194.72000 152.34000 155.65000\narea                  47.36120  93.86304  96.21400  42.86572  13.10191\narea_ch               50.42183 118.42815  97.28110  44.96249  14.63352\nperimeter             31.25521  57.15457  40.52875  28.05989  19.62353\nradius_mean            4.14020   5.44322   5.67334   3.85674   2.46278\nradius_min             2.86360   3.17297   4.05384   2.81686   1.07848\nradius_max             6.44296   7.74344   8.45160   5.84403   4.29209\nradius_sd              0.88544   0.93574   1.24003   0.75387   0.91897\nradius_ratio           0.11430   0.12395   0.10566   0.10516   0.20218\ndiam_mean              8.28091  10.88644  11.34669   7.71347   4.92557\ndiam_min               5.72668   6.34594   8.10768   5.63423   2.15748\ndiam_max              12.88593  15.48689  16.90319  11.68806   8.58368\ncaliper               12.11783  14.25194  16.02638  10.63447   8.53491\nlength                12.11783  14.25194  16.02638  10.63447   8.53491\nwidth                  6.35254  12.07465   8.46582   6.26821   2.74422\nsolidity               0.04775   0.04013   0.05029   0.04826   0.04572\nconvexity              0.90000   0.69000   0.92000   0.91000   0.83000\nelongation             0.48000   0.15000   0.47000   0.41000   0.68000\ncircularity           20.63000  34.80000  17.07000  18.37000  29.39000\ncircularity_haralick   4.68000   5.82000   4.58000   5.12000   2.68000\ncircularity_norm       0.61000   0.36000   0.74000   0.68000   0.43000\neccentricity           0.35000   0.84000   0.40000   0.43000   0.13000\npcv                    1.26000   2.84000   0.43000   0.94000   1.64000\npcv                    1.26000   2.84000   0.43000   0.94000   1.64000\n                             6         7        10        11        14\nid                     6.00000   7.00000   8.00000   9.00000  10.00000\nx                    104.34000 929.08000 341.49000 529.46000 632.11000\ny                    440.98000 375.55000 375.53000 335.35000 405.31000\narea                  79.26049  50.66571  17.18448  23.31608   7.95740\narea_ch               84.41402  51.89796  18.36641  26.65801   8.30579\nperimeter             45.57827  30.70708  20.96567  23.03374  14.44650\nradius_mean            5.73938   4.20014   2.71831   2.88188   1.85674\nradius_min             2.43840   2.72491   1.31978   1.76886   0.78435\nradius_max             9.76884   6.49122   4.62737   4.49021   3.19126\nradius_sd              2.10464   1.07594   1.00635   0.68682   0.70206\nradius_ratio           0.20371   0.12090   0.17831   0.12903   0.20676\ndiam_mean             11.47877   8.40080   5.43662   5.76377   3.71297\ndiam_min               4.87731   5.44982   2.63957   3.53822   1.56870\ndiam_max              19.53717  12.98245   9.25424   8.97992   6.38251\ncaliper               19.07997  12.67206   9.13587   7.73938   6.34340\nlength                19.07997  12.67206   9.13587   7.73938   6.34340\nwidth                  6.66191   5.92531   3.19735   5.81660   1.98425\nsolidity               0.04775   0.04978   0.04775   0.04420   0.04877\nconvexity              0.86000   0.88000   0.92000   0.84000   0.90000\nelongation             0.65000   0.53000   0.65000   0.25000   0.69000\ncircularity           26.21000  18.61000  25.58000  22.75000  26.23000\ncircularity_haralick   2.73000   3.90000   2.70000   4.20000   2.64000\ncircularity_norm       0.48000   0.68000   0.49000   0.55000   0.48000\neccentricity           0.16000   0.32000   0.15000   0.54000   0.14000\npcv                    0.82000   0.85000   1.15000   1.53000   1.75000\npcv                    0.82000   0.85000   1.15000   1.53000   1.75000\n                            15        16        17        18        19\nid                    11.00000  12.00000  13.00000  14.00000  15.00000\nx                    773.02000 446.42000 568.82000 305.39000 633.31000\ny                    430.98000 518.10000 474.33000 534.70000 510.59000\narea                  31.70187  21.38060   3.91870   4.84644   3.28128\narea_ch               34.43477  22.73802   4.00773   6.01805   3.39354\nperimeter             25.54072  23.85365   8.15035  14.50086   7.94004\nradius_mean            3.28574   3.13690   1.14249   1.71907   1.08001\nradius_min             2.22860   1.49403   0.78994   0.29566   0.60147\nradius_max             4.87629   5.42849   1.69215   3.18008   1.69062\nradius_sd              0.65786   1.17653   0.27229   0.81077   0.31293\nradius_ratio           0.11125   0.18440   0.10871   0.54661   0.14275\ndiam_mean              6.57098   6.27380   2.28448   3.43814   2.15951\ndiam_min               4.45668   2.98806   1.58039   0.59080   1.20294\ndiam_max               9.75309  10.85748   3.38480   6.35965   3.38125\ncaliper                8.46023  10.58266   3.36042   6.25704   3.35788\nlength                 8.46023  10.58266   3.36042   6.25704   3.35788\nwidth                  6.41756   3.50114   1.65202   1.53619   1.44272\nsolidity               0.04674   0.04775   0.04978   0.04115   0.04928\nconvexity              0.85000   0.91000   0.92000   0.64000   0.92000\nelongation             0.24000   0.67000   0.51000   0.75000   0.57000\ncircularity           20.58000  26.61000  16.95000  43.39000  19.21000\ncircularity_haralick   4.99000   2.67000   4.20000   2.12000   3.45000\ncircularity_norm       0.61000   0.47000   0.74000   0.29000   0.65000\neccentricity           0.61000   0.13000   0.38000   0.07000   0.28000\npcv                    1.36000   1.07000   3.13000   2.24000   3.12000\npcv                    1.36000   1.07000   3.13000   2.24000   3.12000\n                            20        21        22        23        24\nid                    16.00000  17.00000  18.00000  19.00000  20.00000\nx                    858.65000 751.61000 536.84000 654.67000 199.12000\ny                    557.43000 555.64000 588.83000 630.47000 665.41000\narea                  25.01156   8.53289  21.76383   7.61805  41.96895\narea_ch               25.72640   9.11353  22.01157   8.26321  44.48249\nperimeter             20.93468  13.04900  18.57908  15.30655  27.35428\nradius_mean            2.91541   1.75616   2.67056   1.93345   3.72923\nradius_min             2.18440   1.17958   2.27635   0.70764   3.04038\nradius_max             4.33121   2.75641   3.27203   3.43510   5.32028\nradius_sd              0.61417   0.45161   0.29007   0.77724   0.50698\nradius_ratio           0.10058   0.11887   0.07315   0.24689   0.08890\ndiam_mean              5.83082   3.51180   5.34060   3.86740   7.45795\ndiam_min               4.36829   2.35864   4.55270   1.41478   6.08076\ndiam_max               8.66191   5.51332   6.54456   6.87019  10.64057\ncaliper                8.33476   5.21868   5.10286   6.78078   9.17956\nlength                 8.33476   5.21868   5.10286   6.78078   9.17956\nwidth                  4.57708   2.55778   5.00583   1.91313   6.90321\nsolidity               0.04928   0.04775   0.05029   0.04674   0.04775\nconvexity              0.92000   0.90000   0.85000   0.90000   0.91000\nelongation             0.45000   0.51000   0.02000   0.72000   0.25000\ncircularity           17.52000  19.95000  15.86000  30.75000  17.83000\ncircularity_haralick   4.75000   3.89000   9.21000   2.49000   7.36000\ncircularity_norm       0.72000   0.63000   0.79000   0.41000   0.70000\neccentricity           0.41000   0.31000   0.96000   0.11000   0.65000\npcv                    1.12000   1.99000   1.10000   1.71000   1.20000\npcv                    1.12000   1.99000   1.10000   1.71000   1.20000\n                            25        26        27\nid                    21.00000  22.00000  23.00000\nx                    767.38000 313.05000 428.12000\ny                    675.03000 656.60000 696.30000\narea                  32.48768   4.81418   4.45418\narea_ch               33.99090   5.35741   5.36515\nperimeter             24.34692  10.76401  27.85110\nradius_mean            3.34315   1.42596   3.41681\nradius_min             2.43027   0.83414   0.17475\nradius_max             5.01498   2.42418   6.80872\nradius_sd              0.64465   0.45517   1.95478\nradius_ratio           0.10465   0.14783   1.98018\ndiam_mean              6.68680   2.85140   6.83362\ndiam_min               4.86004   1.66776   0.34950\ndiam_max              10.02944   4.84835  13.61745\ncaliper                8.97687   4.52120  13.52601\nlength                 8.97687   4.52120  13.52601\nwidth                  5.64947   1.82982   0.53137\nsolidity               0.04877   0.04572   0.04216\nconvexity              0.85000   0.75000   0.74000\nelongation             0.37000   0.60000   0.96000\ncircularity           18.25000  24.07000 174.15000\ncircularity_haralick   5.19000   3.13000   1.75000\ncircularity_norm       0.69000   0.52000   0.07000\neccentricity           0.46000   0.19000   0.00000\npcv                    1.03000   2.45000   0.68000\npcv                    1.03000   2.45000   0.68000\n\n\nSome useful functions can be used to manipulate coordinates. In the following example I will show some features implemented in pliman. Just for simplicity, I’ll use only one object.\n\no2 &lt;- cont[[5]]\nplot_polygon(o2)"
  },
  {
    "objectID": "03_analyze.html#rotate-polygons",
    "href": "03_analyze.html#rotate-polygons",
    "title": "Analyze objects",
    "section": "\n2.6 Rotate polygons",
    "text": "2.6 Rotate polygons\npoly_rotate() can be used to rotate the polygon coordinates by an angle (0-360 degrees) in the trigonometric (anti-clockwise) direction.\n\nrot &lt;- poly_rotate(o2, angle = 45)"
  },
  {
    "objectID": "03_analyze.html#invert-polygons",
    "href": "03_analyze.html#invert-polygons",
    "title": "Analyze objects",
    "section": "\n2.7 Invert polygons",
    "text": "2.7 Invert polygons\npoly_flip_x() and poly_flip_y() can be used to flip shapes along the x and y axis, respectively.\n\nflipped &lt;- \n  list(fx = poly_flip_x(o2), \n       fy = poly_flip_y(o2))\n\nplot_polygon(flipped, merge = FALSE)"
  },
  {
    "objectID": "03_analyze.html#perimeter-sampling",
    "href": "03_analyze.html#perimeter-sampling",
    "title": "Analyze objects",
    "section": "\n2.8 Perimeter sampling",
    "text": "2.8 Perimeter sampling\npoly_sample() samples n coordinates between existing points, and poly_sample_prop() samples a proportion of coordinates between existing ones.\n\n# sample 50 coordinates\npoly_sample(o2, n=10) |&gt; plot_polygon()\n\n\n\n# sample 10% of coordinates\npoly_sample_prop(o2, prop = 0.1) |&gt; plot_polygon()"
  },
  {
    "objectID": "03_analyze.html#smoothing",
    "href": "03_analyze.html#smoothing",
    "title": "Analyze objects",
    "section": "\n2.9 smoothing",
    "text": "2.9 smoothing\npoly_smooth() smooths the contour of a polygon by combining prop coordinate point samples and interpolating them using vertices vertices(default is 1000) .\n\nsmoothed &lt;-\n  list( original = o2,\n        s1 = poly_smooth(o2, prop = 0.2, plot = FALSE),\n        s2 = poly_smooth(o2, prop = 0.1, plot = FALSE),\n        s1 = poly_smooth(o2, prop = 0.04, plot = FALSE)\n  )\n\nplot_polygon(smoothed, merge = FALSE, ncol = 2, aspect_ratio = 1)"
  },
  {
    "objectID": "03_analyze.html#noises",
    "href": "03_analyze.html#noises",
    "title": "Analyze objects",
    "section": "\n2.10 Noises",
    "text": "2.10 Noises\npoly_jitter() adds a small amount of noise to a set of coordinates. See base::jitter() for more details.\n\nset.seed(1)\nc1 &lt;- draw_circle(n = 200, plot = FALSE)\nc2 &lt;- draw_circle(n = 200, plot = FALSE) |&gt;\n  poly_jitter(noise_x = 100,\n              noise_y = 100,\n              plot = FALSE)\n\nplot_polygon(list(c1, c2), merge = FALSE)"
  },
  {
    "objectID": "03_analyze.html#adjusting-object-measurements",
    "href": "03_analyze.html#adjusting-object-measurements",
    "title": "Analyze objects",
    "section": "\n3.1 Adjusting object measurements",
    "text": "3.1 Adjusting object measurements\nThe results were stored in img_res. Since there is no scale declared in the example above, we have no idea about the actual area of objects in cm\\(^2\\), only in pixels. In this case, we use get_measures() to adjust pixel measurements to metric units.\nThere are two main ways to adjust object measurements (from pixels to cm, for example). The first is to declare the known area, perimeter or radius of a given object. The measure for the other objects will then be calculated by a simple rule of three. The second is by declaring a known image resolution in dpi(dots per inch). In this case, perimeter, area, and radius will be adjusted by the dpi informed.\n\n3.1.1 Declaring a known value\nSince we know the area of the larger square (object 1), let’s adjust the area of the other objects in the image using this.\n\nget_measures(img_res ,\n             id = 1,\n             area ~ 100) |&gt; \n  t()\n\n-----------------------------------------\nmeasures corrected with:\nobject id: 1\narea     : 100\n-----------------------------------------\nTotal    : 40.009 \nAverage  : 13.336 \n-----------------------------------------\n\n\n                              2          3          4\nid                      2.00000    3.00000    4.00000\nx                    1736.51589 1736.57088 1736.96695\ny                     451.99673 1295.35408  938.00393\narea                   25.04122    7.01935    7.94891\narea_ch                24.95759    7.02186    7.90671\nperimeter              19.98294   10.09779   11.91303\nradius_mean             2.86590    1.49087    1.66756\nradius_min              2.49152    1.47805    0.98799\nradius_max              3.53105    1.50513    2.22447\nradius_sd               0.31408    0.00379    0.42266\ndiam_mean               5.73181    2.98173    3.33512\ndiam_min                4.98303    2.95611    1.97598\ndiam_max                7.06211    3.01026    4.44894\nmajor_axis              2.04045    1.05585    1.48148\nminor_axis              2.03680    1.05256    0.87434\ncaliper                 7.01731    2.99894    4.43833\nlength                  6.51989    2.99478    3.99360\nwidth                   6.50883    2.99566    1.98719\nradius_ratio            1.41723    1.01832    2.25152\ntheta                  -1.18050   -1.35228    0.00105\neccentricity            0.05980    0.07886    0.80727\nform_factor             0.78804    0.86507    0.70384\nnarrow_factor           1.07629    1.00139    1.11136\nasp_ratio               1.00170    0.99971    2.00967\nrectangularity          1.69468    1.27809    0.99838\npd_ratio                2.84766    3.36712    2.68412\nplw_ratio               1.53376    1.68565    1.99188\nsolidity                1.00335    0.99964    1.00534\nconvexity               0.74873    0.90505    0.83591\nelongation              0.00170   -0.00029    0.50241\ncircularity            15.94643   14.52634   17.85407\ncircularity_haralick    9.12467  393.24974    3.94539\ncircularity_norm        0.78537    0.86045    0.69937\ncoverage                0.10684    0.02995    0.03392\n\n\n\n3.1.2 Declaring the image resolution\nIf the image resolution is known, all measurements will be adjusted accordingly. Let’s see a numerical example with pixels_to_cm(). This function converts the number of pixels(* px *) into cm, considering the image resolution in dpi, as follows: \\(cm = px \\times(2.54 / dpi)\\). As we know the number of pixels of the larger square, its perimeter in cm is given by\n\n# number of pixels for the perimeter of the largest square\n\nls_px &lt;- img_res$results$perimeter[1]\npixels_to_cm(px = ls_px , dpi = 300)\n\n[1] 39.9265\n\n\nThe perimeter of object 1 adjusted by image resolution is very close to the known value (40 cm). Below, the values of all measures are adjusted by declaring the dpi argument in get_measures().\n\nimg_res_cor &lt;- get_measures(img_res, dpi = 300)\n\nt(img_res_cor)\n\n                             1          2          3          4\nid                     1.00000    2.00000    3.00000    4.00000\nx                    667.99511 1736.51589 1736.57088 1736.96695\ny                    796.99281  451.99673 1295.35408  938.00393\narea                  99.81199   24.99414    7.00615    7.93396\narea_ch               99.68629   24.91067    7.00866    7.89185\nperimeter             39.92650   19.96415   10.08830   11.90183\nradius_mean            5.72789    2.86321    1.48946    1.66599\nradius_min             4.98370    2.48917    1.47666    0.98706\nradius_max             7.05698    3.52773    1.50371    2.22238\nradius_sd              0.62876    0.31379    0.00379    0.42226\ndiam_mean             11.45577    5.72641    2.97893    3.33198\ndiam_min               9.96740    4.97834    2.95333    1.97412\ndiam_max              14.11395    7.05547    3.00743    4.44476\nmajor_axis             4.07720    2.03853    1.05486    1.48009\nminor_axis             4.07190    2.03488    1.05157    0.87352\ncaliper               14.03942    7.01071    2.99612    4.43416\nlength                11.12135    6.51376    2.99197    3.98985\nwidth                 11.10659    6.50271    2.99284    1.98532\nradius_ratio           1.41601    1.41723    1.01832    2.25152\ntheta                  0.12122   -1.18050   -1.35228    0.00105\neccentricity           0.05093    0.05980    0.07886    0.80727\nform_factor            0.78681    0.78804    0.86507    0.70384\nnarrow_factor          1.26238    1.07629    1.00139    1.11136\nasp_ratio              1.00133    1.00170    0.99971    2.00967\nrectangularity         1.23753    1.69468    1.27809    0.99838\npd_ratio               2.84388    2.84766    3.36712    2.68412\nplw_ratio              1.79623    1.53376    1.68565    1.99188\nsolidity               1.00126    1.00335    0.99964    1.00534\nconvexity              0.75029    0.74873    0.90505    0.83591\nelongation             0.00133    0.00170   -0.00029    0.50241\ncircularity           15.97128   15.94643   14.52634   17.85407\ncircularity_haralick   9.10975    9.12467  393.24974    3.94539\ncircularity_norm       0.78548    0.78537    0.86045    0.69937\ncoverage               0.42666    0.10684    0.02995    0.03392\n\n\n\n3.1.3 Understanding measurements\n\nobject_contour(img) %&gt;% # get the contour of objects\n  poly_mass() %&gt;% # computes the center of mass and minimum and maximum radii\n  plot_mass() # plot the measurements\n\n\n\n\n\nLarger square:\nThe minimum diameter(a = 9.97) can be considered as the side of the square\nThe maximum diameter, given by \\(a \\sqrt {2}\\) can be considered the diagonal of the square (\\(9.97 \\sqrt {2} = 14,099 \\approx 14,105\\)\n\n\n\nt(img_res_cor)\n\n                             1          2          3          4\nid                     1.00000    2.00000    3.00000    4.00000\nx                    667.99511 1736.51589 1736.57088 1736.96695\ny                    796.99281  451.99673 1295.35408  938.00393\narea                  99.81199   24.99414    7.00615    7.93396\narea_ch               99.68629   24.91067    7.00866    7.89185\nperimeter             39.92650   19.96415   10.08830   11.90183\nradius_mean            5.72789    2.86321    1.48946    1.66599\nradius_min             4.98370    2.48917    1.47666    0.98706\nradius_max             7.05698    3.52773    1.50371    2.22238\nradius_sd              0.62876    0.31379    0.00379    0.42226\ndiam_mean             11.45577    5.72641    2.97893    3.33198\ndiam_min               9.96740    4.97834    2.95333    1.97412\ndiam_max              14.11395    7.05547    3.00743    4.44476\nmajor_axis             4.07720    2.03853    1.05486    1.48009\nminor_axis             4.07190    2.03488    1.05157    0.87352\ncaliper               14.03942    7.01071    2.99612    4.43416\nlength                11.12135    6.51376    2.99197    3.98985\nwidth                 11.10659    6.50271    2.99284    1.98532\nradius_ratio           1.41601    1.41723    1.01832    2.25152\ntheta                  0.12122   -1.18050   -1.35228    0.00105\neccentricity           0.05093    0.05980    0.07886    0.80727\nform_factor            0.78681    0.78804    0.86507    0.70384\nnarrow_factor          1.26238    1.07629    1.00139    1.11136\nasp_ratio              1.00133    1.00170    0.99971    2.00967\nrectangularity         1.23753    1.69468    1.27809    0.99838\npd_ratio               2.84388    2.84766    3.36712    2.68412\nplw_ratio              1.79623    1.53376    1.68565    1.99188\nsolidity               1.00126    1.00335    0.99964    1.00534\nconvexity              0.75029    0.74873    0.90505    0.83591\nelongation             0.00133    0.00170   -0.00029    0.50241\ncircularity           15.97128   15.94643   14.52634   17.85407\ncircularity_haralick   9.10975    9.12467  393.24974    3.94539\ncircularity_norm       0.78548    0.78537    0.86045    0.69937\ncoverage               0.42666    0.10684    0.02995    0.03392"
  },
  {
    "objectID": "03_analyze.html#texture-features",
    "href": "03_analyze.html#texture-features",
    "title": "Analyze objects",
    "section": "\n3.2 Texture features",
    "text": "3.2 Texture features\nThe function computes 13 Haralick texture features for each object based on a gray-level co-occurrence matrix (Haralick et al. 1979)8. Haralick features depend on the configuration of the parameters har_nbins and har_scales. har_nbins controls the number of bins used to compute the Haralick matrix. A smaller har_nbins can give more accurate estimates of the correlation because the number of events per bin is higher. While a higher value will give more sensitivity. har_scales controls the number of scales used to compute the Haralick features. Since Haralick features compute the correlation of intensities of neighboring pixels, it is possible to identify textures with different scales, e.g., a texture that is repeated every two pixels or 10 pixels. By default, the Haralick features are computed with the R band. To change this default, use the argument har_band. For example, har_band = 2 will compute the features with the green band.\nThe following measures are returned (for more details, see this post)\n\n\nasm: The angular second-moment feature.\n\ncon: The contrast feature\n\ncor: Correlation measures the linear dependency of gray levels of neighboring pixels.\n\nvar: The variance of gray levels pixels.\n\nidm: The Inverse Difference Moment (IDM), i.e., the local homogeneity.\n\nsav: The Sum Average.\n\nsva: The Sum Variance.\n\nsen: Sum Entropy.\n\ndva: Difference Variance.\n\nden: Difference Entropy\n\nf12: Difference Variance.\n\nf13: The angular second-moment feature."
  },
  {
    "objectID": "03_analyze.html#single-image-processing",
    "href": "03_analyze.html#single-image-processing",
    "title": "Analyze objects",
    "section": "\n3.3 Single image processing",
    "text": "3.3 Single image processing\nThe analyze_objects() function calculates a range of measurements that can be used to study the shape and texture of objects, such as leaves. In the following example, I show how to plot the length and width of each leaf in the following image.\n\nleaves &lt;- image_import(\"folhas.jpg\", plot = TRUE)\n\nleaves_meas &lt;-\n  analyze_objects(leaves,\n                  watershed = FALSE)\n\nleaves_cor &lt;- get_measures(leaves_meas, dpi = 300)\n\nt(leaves_cor)\n\n                             1         2\nid                     1.00000   2.00000\nx                    527.55799 232.98225\ny                    298.91031 824.80531\narea                   5.86235   3.87949\narea_ch                5.94565   4.22712\nperimeter             12.16180   9.94191\nradius_mean            1.59090   1.14499\nradius_min             0.73539   0.83769\nradius_max             2.68488   1.67672\nradius_sd              0.58172   0.21951\ndiam_mean              3.18180   2.28999\ndiam_min               1.47078   1.67538\ndiam_max               5.36976   3.35344\nmajor_axis             1.58955   0.97653\nminor_axis             0.58515   0.63683\ncaliper                5.23440   3.20489\nlength                 5.24101   3.20957\nwidth                  1.60227   1.88314\nradius_ratio           3.65097   2.00160\ntheta                 -1.04997  -0.04881\neccentricity           0.92978   0.75810\nform_factor            0.49807   0.49322\nnarrow_factor          0.99874   0.99854\nasp_ratio              3.27100   1.70436\nrectangularity         1.43244   1.55796\npd_ratio               2.32344   3.10211\nplw_ratio              1.77719   1.95219\nsolidity               0.98599   0.91776\nconvexity              0.91242   0.79138\nelongation             0.69428   0.41327\ncircularity           25.23036  25.47800\ncircularity_haralick   2.73482   5.21617\ncircularity_norm       0.49436   0.48864\ncoverage               0.10392   0.06877\n\n# plot width and length\nplot_measures(leaves_cor , measure = \"width\")\nplot_measures(leaves_cor , measure = \"length\", vjust = 50)\n\n\n\n\nHere, we will count the grains in the grains.jpg image. This image has a cyan background and contains 90 soybeans that touch each other. The analyze_objects() function segments the image using the normalized blue index by default, as follows \\(NB =(B /(R + G + B))\\), where R, G and B are the red, green and blue bands. Note that if the image is contained in the default directory, it is not necessary to import it. Just enter the image name in quotes in the img argument(e.g., img = \"grains\").\nIn this example, objects are counted and segmented objects are colored with random colors using the show_segmentation = TRUE argument. Users can set show_contour = FALSE to remove the contour line and identify the objects (in this example, the grains) using the marker = \"id\" arguments. The background color can also be changed with col_background.\n\ncount &lt;-\n  analyze_objects(img = \"grains\",\n                  show_segmentation = TRUE,\n                  show_contour = FALSE,\n                  marker = \"id\")\n\n\n\ncount$statistics\n\n       stat        value\n1         n 9.000000e+01\n2  min_area 4.440000e+02\n3 mean_area 6.731000e+02\n4  max_area 8.400000e+02\n5   sd_area 7.179435e+01\n6  sum_area 6.057900e+04\n7  coverage 5.196747e-02\n\n\n\n# Get the measurements of the object\nget_measures(count) |&gt; \n  head() |&gt; \n  t()\n\n                             1         2         3         4         5\nid                     1.00000   2.00000   3.00000   4.00000   5.00000\nx                    350.85885 823.97070 810.25934 709.00419 806.08333\ny                    410.19954 263.76794 197.83538 261.79469 341.01925\narea                 840.00000 822.00000 735.00000 761.00000 755.00000\narea_ch              809.00000 806.50000 711.00000 733.00000 724.00000\nperimeter            104.49747 108.49747  98.49747 100.25483  99.42641\nradius_mean           15.89263  15.72760  14.84635  15.11219  15.04126\nradius_min            14.82535  13.73620  14.14058  12.88636  13.64198\nradius_max            16.89040  17.80771  15.38458  17.04844  16.73018\nradius_sd              0.47873   1.20792   0.31891   1.18211   0.81518\ndiam_mean             31.78526  31.45520  29.69270  30.22438  30.08252\ndiam_min              29.65071  27.47239  28.28116  25.77273  27.28396\ndiam_max              33.78080  35.61543  30.76917  34.09688  33.46037\nmajor_axis            11.43632  11.90210  10.56633  11.46245  11.14716\nminor_axis            11.04595  10.35090  10.43395   9.91827  10.13100\ncaliper               33.52611  35.46830  30.59412  33.83785  33.12099\nlength                33.49452  35.36845  30.47650  33.81768  33.01793\nwidth                 32.03030  29.77299  30.04568  27.70773  29.39465\nradius_ratio           1.13929   1.29641   1.08797   1.32298   1.22638\ntheta                  1.22449  -0.30022  -0.84102  -0.29657   0.58308\neccentricity           0.25904   0.49363   0.15780   0.50128   0.41714\nform_factor            0.96667   0.87749   0.95202   0.95145   0.95974\nnarrow_factor          1.00094   1.00282   1.00386   1.00060   1.00312\nasp_ratio              1.04571   1.18794   1.01434   1.22051   1.12326\nrectangularity         1.27719   1.28105   1.24583   1.23129   1.28550\npd_ratio               3.11690   3.05900   3.21949   2.96280   3.00192\nplw_ratio              1.59478   1.66557   1.62746   1.62949   1.59305\nsolidity               1.03832   1.01922   1.03376   1.03820   1.04282\nconvexity              0.94526   0.91214   0.90327   0.88220   0.86156\nelongation             0.04372   0.15820   0.01414   0.18067   0.10974\ncircularity           12.99967  14.32081  13.19966  13.20766  13.09352\ncircularity_haralick  33.19729  13.02043  46.55411  12.78406  18.45156\ncircularity_norm       0.91316   0.82572   0.89568   0.89518   0.90254\ncoverage               0.00072   0.00071   0.00063   0.00065   0.00065\n                             6\nid                     6.00000\nx                    817.90089\ny                    713.82865\narea                 739.00000\narea_ch              713.00000\nperimeter             98.84062\nradius_mean           14.87775\nradius_min            13.79271\nradius_max            16.25471\nradius_sd              0.61950\ndiam_mean             29.75550\ndiam_min              27.58541\ndiam_max              32.50943\nmajor_axis            10.89320\nminor_axis            10.15209\ncaliper               31.89044\nlength                31.76844\nwidth                 29.09858\nradius_ratio           1.17850\ntheta                 -1.12183\neccentricity           0.36255\nform_factor            0.95057\nnarrow_factor          1.00384\nasp_ratio              1.09175\nrectangularity         1.25090\npd_ratio               3.09938\nplw_ratio              1.62388\nsolidity               1.03647\nconvexity              0.88516\nelongation             0.08404\ncircularity           13.21985\ncircularity_haralick  24.01584\ncircularity_norm       0.89333\ncoverage               0.00063\n\n\nIn the following example, we will select objects with an area above the average of all objects using lower_size = 675.\n\n#\n\nanalyze_objects(\"grains\",\n                marker = \"id\",\n                topn_upper = 5)\n\n\n\n\nUsers can also use the topn _* arguments to select the n objects based on the smallest or largest areas. Let’s see how to select the 5 grains with the smallest area, showing the original grains on a blue background. We will also use the my_index argument to choose a custom index to segment the image. Just for comparison, we will explicitly set the normalized blue index by calling my_index = \"B /(R + G + B)\".\n\nanalyze_objects(\"grains\",\n                marker = \"id\",\n                topn_lower = 5,\n                col_background = \"black\",\n                index = \"B /(R + G + B)\") # normalized blue(NB)"
  },
  {
    "objectID": "03_analyze.html#batch-processing",
    "href": "03_analyze.html#batch-processing",
    "title": "Analyze objects",
    "section": "\n3.4 Batch processing",
    "text": "3.4 Batch processing\nIn image analysis, it is often necessary to process more than one image. For example, in plant breeding, the number of grains per plant(eg wheat) is often used in the indirect selection of high-yielding plants. In pliman, batch processing can be done when the user declares the pattern argument.\nTo speed up processing time, especially for large numbers of images, the parallel = TRUE argument can be used. In this case, images are processed asynchronously (in parallel) in separate R sessions running in the background on the same machine. The number of sections is set to 50% of available cores. This number can be explicitly controlled with the workers argument.\n\nsystem.time(\n  list_res &lt;- analyze_objects(pattern = \"img_sb\",\n                              verbose = FALSE,\n                              plot =  FALSE,\n                              dir_original = \"soja\")\n)\n\n  usuário   sistema decorrido \n     2.05      0.17      2.54 \n\n# parallel processing\n# 6 multiple sections (50% of my pc's cores)\nsystem.time(\n  list_res &lt;-\n    analyze_objects(pattern = \"img_sb\",\n                    verbose = FALSE,\n                    plot =  FALSE,\n                    dir_original = \"soja\",\n                    parallel = TRUE)\n)\n\n  usuário   sistema decorrido \n     0.12      0.00     17.77"
  },
  {
    "objectID": "03_analyze.html#known-resolution",
    "href": "03_analyze.html#known-resolution",
    "title": "Analyze objects",
    "section": "\n8.1 Known resolution",
    "text": "8.1 Known resolution\n\nleaves &lt;- image_import(\"ref_leaves.jpg\", plot = TRUE)\n\n\n\naf &lt;-\n  analyze_objects(leaves,\n                  index = \"B-G\",\n                  watershed = FALSE,\n                  col_background = \"black\",\n                  marker = \"id\")\n\n# using images with known resolution\naf_cor &lt;- get_measures(af, dpi = 45.8)\nplot_measures(af_cor ,\n              measure = \"area\",\n              vjust = -20,\n              col = \" cyan \")\n\n# declaring the measure of a known object\naf_cor2 &lt;- \n  get_measures(af,\n               id = 18,\n               measure = area ~ 25)\n\n-----------------------------------------\nmeasures corrected with:\nobject id: 18\narea     : 25\n-----------------------------------------\nTotal    : 796.959 \nAverage  : 36.225 \n-----------------------------------------\n\nplot_measures(af_cor2 ,\n              measure = \"area\",\n              vjust = -35,\n              col = \"salmon\")"
  },
  {
    "objectID": "03_analyze.html#reference-object-dev-version",
    "href": "03_analyze.html#reference-object-dev-version",
    "title": "Analyze objects",
    "section": "\n8.2 Reference object (dev version)",
    "text": "8.2 Reference object (dev version)\n\n8.2.1 Single images\nThe reference argument can now be used to correct the object measures even when images with different shooting distances are used. This differs from the previous example (declaring the object with the known area) in a subtle, but crucial aspect: when reference is informed, batch processing can be used! In this example, the leaf area of the ref_leaves image is quantified and corrected considering a 5 x 5 (25 cm\\(^2\\)) red square as the reference object. When reference = TRUE is informed in analyze_objects() the function will perform a two-step process of object segmentation; so, the time processing is a bit slower.\nThe first step consists in segmenting the foreground (leaves and reference object) from the background. To do that, an image index is used and can be declared in the back_fore_index. The default (back_fore_index = \"R/(G/B)\") is optimized to segment white backgrounds from green leaves and a blue reference object. Let’s see how this index performs in this example.\n\nimg &lt;- image_import(\"ref_leaves.jpg\", plot = TRUE)\n\n\n\nind &lt;- image_index(img, index = \"R/(G/B)\", plot =  FALSE)[[1]]\n\nIndex 'R/(G/B)' is not available. Trying to compute your own index.\n\nbin &lt;- image_binary(img, index = \"R/(G/B)\", plot =  FALSE)[[1]]\n\nIndex 'R/(G/B)' is not available. Trying to compute your own index.\n\nimage_combine(ind, bin)\n\n\n\n\nThis index definitively is not the better option in this case. Will some other available index be better?\n\nimage_index(img, index = \"all\")\n\nWarning: The number of layers is too large and plots may not fit well to the\nplot area. Consider reducing the number of indexes used.\n\n\n\n\n\nThe B-G index seems to be a good candidate.\n\nind &lt;- image_index(img, index = \"B-G\", plot =  FALSE)[[1]]\nseg1 &lt;- image_segment(img, index = \"B-G\", plot =  FALSE)\nimage_combine(ind, seg1)\n\n\n\n\nGood job! now, we have the background removed. The next step is to segment the objects and the reference template. We basically need to repeat the previous step isolating the reference.\n\n# see the better index\nimage_index(seg1, index = \"all\")\n\nWarning: The number of layers is too large and plots may not fit well to the\nplot area. Consider reducing the number of indexes used.\n\n\n\n\n\nThe R-G is a good candidate. So, I’ll perform the second segmentation using this index.\n\nseg2 &lt;- \n  image_binary(seg1,\n               index = \"R-G\")\n\n\n\n# number of pixels in the reference object\nlength(which(seg2$`R-G` != 1))\n\n[1] 8108\n\n\nNow that we know the indexes to be used for each segmentation, we can use the function analyze_objects to get the corrected measures based on the reference object.\n\nres1 &lt;- \n  analyze_objects(img, \n                  reference = TRUE,\n                  reference_area = 25,\n                  back_fore_index = \"B-G\",\n                  fore_ref_index = \"R-G\",\n                  watershed = FALSE,\n                  marker = \"area\")\n\n# plot the measures corrected by the image resolution\nplot_measures(af_cor ,\n              measure = \"area\",\n              vjust = -20,\n              col = \" cyan \")\n\n\n\n\n\n8.2.2 Multiple images\nIf users need to analyze multiple images from the same sample, the images must share the same filename prefix, which is defined as the part of the filename that precedes the first hyphen (-) or underscore (_). Then, when using get_measures(), measurements from leaf images called, for example, F1-1.jpeg, F1_2.jpeg and F1-3.jpeg will be combined into a single image (F1), displayed in the merge object. This is useful, for example, for analyzing large sheets that need to be split into multiple images or multiple sheets belonging to the same sample that cannot be scanned into a single image.\nIn the following example, 36 images will be analyzed. These images contain flax leaves from 12 evaluation dates, with three replications10. Note that to ensure that all images are processed, all images must share a common pattern, in this case (\"A\"). Here, I will use the pattern = \"A\" to indicate that all images with this pattern name should be merged.\n\nres &lt;-\n  analyze_objects(pattern = \"A\",\n                  dir_original = \"linhaca\",\n                  reference = TRUE,\n                  reference_area = 20,\n                  watershed = FALSE,\n                  filter = 2,\n                  parallel = TRUE)\n\nProcessing 36 images in multiple sessions (6). Please, wait.\n\n\n--------------------------------------------\n     Image Objects\n   A1_28_1      18\n   A1_28_2      29\n   A1_28_3      28\n  A10_90_1     149\n  A10_90_2     116\n  A10_90_3      77\n  A11_98_1     133\n  A11_98_2     154\n  A11_98_3     119\n A12_105_1     111\n A12_105_2     127\n A12_105_3     155\n   A2_32_1      24\n   A2_32_2      25\n   A2_32_3      31\n   A3_42_1      39\n   A3_42_2      47\n   A3_42_3      54\n   A4_46_1      57\n   A4_46_2      38\n   A4_46_3      56\n   A5_55_1      53\n   A5_55_2      74\n   A5_55_3      63\n   A6_63_1      68\n   A6_63_2     105\n   A6_63_3      83\n   A7_70_1      98\n   A7_70_2     111\n   A7_70_3     112\n   A8_76_1     113\n   A8_76_2     116\n   A8_76_3     113\n   A9_83_1     119\n   A9_83_2      89\n   A9_83_3     100\n--------------------------------------------\n\n\nDone!\n\n\nElapsed time: 00:00:40\n\nmerged &lt;- get_measures(res)\n\nNote that the merged is a list with three objects:\n\n\nresults: a data frame that contains the measurements of each individual object (in this case, an individual leaf) of each analyzed image.\n\n\nmerged$results |&gt; head(n = 5) |&gt; t()\n\n                     1          2          3          4          5         \nimg                  \"A1_28_1\"  \"A1_28_1\"  \"A1_28_1\"  \"A1_28_1\"  \"A1_28_1\" \nid                   \"1\"        \"2\"        \"3\"        \"4\"        \"5\"       \nx                    \"372.0789\" \"421.4407\" \"162.9520\" \"126.3978\" \"266.4682\"\ny                    \"315.9907\" \"319.3856\" \"349.6462\" \"386.7082\" \"399.5777\"\narea                 \"0.11514\"  \"0.15914\"  \"0.15721\"  \"0.19485\"  \"0.20121\" \narea_ch              \"0.15056\"  \"0.19042\"  \"0.15098\"  \"0.19291\"  \"0.22515\" \nperimeter            \"2.09472\"  \"2.11421\"  \"1.70686\"  \"2.29741\"  \"2.13036\" \nradius_mean          \"0.24918\"  \"0.26147\"  \"0.23023\"  \"0.30151\"  \"0.26289\" \nradius_min           \"0.00981\"  \"0.06450\"  \"0.11653\"  \"0.09891\"  \"0.11571\" \nradius_max           \"0.47779\"  \"0.45243\"  \"0.36772\"  \"0.51707\"  \"0.42928\" \nradius_sd            \"0.12621\"  \"0.11123\"  \"0.07650\"  \"0.13080\"  \"0.09084\" \ndiam_mean            \"0.49836\"  \"0.52294\"  \"0.46046\"  \"0.60303\"  \"0.52578\" \ndiam_min             \"0.01962\"  \"0.12899\"  \"0.23307\"  \"0.19781\"  \"0.23143\" \ndiam_max             \"0.95558\"  \"0.90487\"  \"0.73543\"  \"1.03413\"  \"0.85855\" \nmajor_axis           \"0.26979\"  \"0.26867\"  \"0.21949\"  \"0.31601\"  \"0.24862\" \nminor_axis           \"0.07137\"  \"0.09192\"  \"0.10304\"  \"0.08948\"  \"0.12441\" \ncaliper              \"0.91076\"  \"0.87337\"  \"0.72478\"  \"1.02769\"  \"0.80493\" \nlength               \"0.90912\"  \"0.87174\"  \"0.72291\"  \"1.02496\"  \"0.80212\" \nwidth                \"0.23326\"  \"0.30972\"  \"0.28295\"  \"0.23797\"  \"0.42684\" \nradius_ratio         \"48.71382\" \" 7.01490\" \" 3.15544\" \" 5.22783\" \" 3.70981\"\ntheta                \"-1.46559\" \" 1.32218\" \" 0.08942\" \"-0.58010\" \"-1.17190\"\neccentricity         \"0.96438\"  \"0.93965\"  \"0.88296\"  \"0.95907\"  \"0.86580\" \nform_factor          \"0.32974\"  \"0.44741\"  \"0.67808\"  \"0.46390\"  \"0.55713\" \nnarrow_factor        \"1.00180\"  \"1.00187\"  \"1.00259\"  \"1.00267\"  \"1.00351\" \nasp_ratio            \"3.89739\"  \"2.81464\"  \"2.55492\"  \"4.30702\"  \"1.87920\" \nrectangularity       \"1.84187\"  \"1.69655\"  \"1.30113\"  \"1.25182\"  \"1.70157\" \npd_ratio             \"2.29997\"  \"2.42074\"  \"2.35500\"  \"2.23550\"  \"2.64662\" \nplw_ratio            \"1.83363\"  \"1.78949\"  \"1.69693\"  \"1.81911\"  \"1.73347\" \nsolidity             \"0.76471\"  \"0.83576\"  \"1.04125\"  \"1.01004\"  \"0.89367\" \nconvexity            \"0.55229\"  \"0.55353\"  \"0.91615\"  \"0.91475\"  \"0.74206\" \nelongation           \"0.74342\"  \"0.64472\"  \"0.60860\"  \"0.76782\"  \"0.46786\" \ncircularity          \"38.10998\" \"28.08723\" \"18.53230\" \"27.08857\" \"22.55541\"\ncircularity_haralick \"1.97429\"  \"2.35064\"  \"3.00944\"  \"2.30524\"  \"2.89416\" \ncircularity_norm     \"0.28456\"  \"0.40228\"  \"0.62197\"  \"0.42601\"  \"0.51422\" \ncoverage             \"0.00113\"  \"0.00156\"  \"0.00154\"  \"0.00191\"  \"0.00197\" \n\n\n\n\nsummary : a data frame that contains the summary of the results, containing the number of objects in each image (n) the sum, mean and standard deviation of the area of each image, as well as the average value for all others measurements (perimeter, radius, etc.)\n\n\nmerged$summary |&gt; head(n = 5) |&gt; t()\n\n                     1            2            3            4            \nimg                  \"imgA1_28_1\" \"imgA1_28_2\" \"imgA1_28_3\" \"imgA10_90_1\"\nn                    \" 18\"        \" 29\"        \" 28\"        \"149\"        \narea_sum             \"  2.56594\"  \"  6.29361\"  \"  7.04808\"  \"171.90417\"  \narea_mean            \"0.14255\"    \"0.21702\"    \"0.25172\"    \"1.15372\"    \narea_sd              \"0.05759\"    \"0.07495\"    \"0.09524\"    \"0.43971\"    \narea_ch              \"0.16279\"    \"0.21887\"    \"0.27358\"    \"1.21400\"    \nperimeter            \"2.00362\"    \"2.71748\"    \"2.71511\"    \"6.54996\"    \nradius_mean          \"0.24832\"    \"0.34275\"    \"0.33846\"    \"0.81144\"    \nradius_min           \"0.07567\"    \"0.07876\"    \"0.10713\"    \"0.18661\"    \nradius_max           \"0.43423\"    \"0.62526\"    \"0.60196\"    \"1.50957\"    \nradius_sd            \"0.10638\"    \"0.16549\"    \"0.14840\"    \"0.40285\"    \ndiam_mean            \"0.49665\"    \"0.68550\"    \"0.67693\"    \"1.62288\"    \ndiam_min             \"0.15134\"    \"0.15753\"    \"0.21426\"    \"0.37322\"    \ndiam_max             \"0.86847\"    \"1.25052\"    \"1.20392\"    \"3.01914\"    \nmajor_axis           \"0.25413\"    \"0.37116\"    \"0.35314\"    \"0.88572\"    \nminor_axis           \"0.08556\"    \"0.08191\"    \"0.10610\"    \"0.18347\"    \ncaliper              \"0.83830\"    \"1.23288\"    \"1.17672\"    \"2.97301\"    \nlength               \"0.83666\"    \"1.23244\"    \"1.17617\"    \"2.97448\"    \nwidth                \"0.26194\"    \"0.22838\"    \"0.30106\"    \"0.51589\"    \nradius_ratio         \" 8.74014\"   \"10.30621\"   \" 5.72830\"   \" 9.70617\"   \ntheta                \" 0.02449\"   \"-0.10613\"   \" 0.26184\"   \" 0.07055\"   \neccentricity         \"0.92820\"    \"0.97374\"    \"0.95030\"    \"0.97749\"    \nform_factor          \"0.46118\"    \"0.36111\"    \"0.43781\"    \"0.33784\"    \nnarrow_factor        \"1.00176\"    \"1.00039\"    \"1.00069\"    \"0.99980\"    \nasp_ratio            \"3.88030\"    \"5.64527\"    \"4.24631\"    \"6.23272\"    \nrectangularity       \"1.51394\"    \"1.32901\"    \"1.39147\"    \"1.33923\"    \npd_ratio             \"2.36860\"    \"2.20665\"    \"2.29786\"    \"2.19253\"    \nplw_ratio            \"1.81024\"    \"1.86072\"    \"1.83281\"    \"1.87284\"    \nsolidity             \"0.95496\"    \"0.98661\"    \"0.98786\"    \"1.01775\"    \nconvexity            \"0.77426\"    \"0.77286\"    \"0.84992\"    \"0.85640\"    \nelongation           \"0.69142\"    \"0.81273\"    \"0.74698\"    \"0.82959\"    \ncircularity          \"30.16456\"   \"36.25009\"   \"29.78587\"   \"38.46601\"   \ncircularity_haralick \"2.37631\"    \"2.08159\"    \"2.31270\"    \"2.01769\"    \ncircularity_norm     \"0.41143\"    \"0.32685\"    \"0.40763\"    \"0.30386\"    \ncoverage             \"0.00140\"    \"0.00128\"    \"0.00141\"    \"0.00076\"    \n                     5            \nimg                  \"imgA10_90_2\"\nn                    \"116\"        \narea_sum             \"119.06277\"  \narea_mean            \"1.02640\"    \narea_sd              \"0.33712\"    \narea_ch              \"1.13381\"    \nperimeter            \"6.38542\"    \nradius_mean          \"0.77889\"    \nradius_min           \"0.16397\"    \nradius_max           \"1.46491\"    \nradius_sd            \"0.39273\"    \ndiam_mean            \"1.55778\"    \ndiam_min             \"0.32795\"    \ndiam_max             \"2.92982\"    \nmajor_axis           \"0.85230\"    \nminor_axis           \"0.17488\"    \ncaliper              \"2.87974\"    \nlength               \"2.87874\"    \nwidth                \"0.50404\"    \nradius_ratio         \"10.20943\"   \ntheta                \" 0.03805\"   \neccentricity         \"0.97582\"    \nform_factor          \"0.33066\"    \nnarrow_factor        \"1.00079\"    \nasp_ratio            \"6.24416\"    \nrectangularity       \"1.39066\"    \npd_ratio             \"2.20709\"    \nplw_ratio            \"1.88076\"    \nsolidity             \"0.99459\"    \nconvexity            \"0.85418\"    \nelongation           \"0.82530\"    \ncircularity          \"40.13084\"   \ncircularity_haralick \"2.00092\"    \ncircularity_norm     \"0.29394\"    \ncoverage             \"0.00069\"    \n\n\nThe area_sum of img A1_28_1 is the sum of the 18 leaves.\n\nsum(merged$results$area[1:18])\n\n[1] 2.56595\n\n\n\n\nmerge: a data frame that contains the results merged by image prefix (In this case, A1 to A12).\n\n\nmerged$merge |&gt; head(n = 5) |&gt; t()\n\n                     1           2           3           4          \nimg                  \"imgA1\"     \"imgA10\"    \"imgA11\"    \"imgA12\"   \nn                    \" 75\"       \"342\"       \"406\"       \"393\"      \narea_sum             \" 15.90763\" \"364.00764\" \"478.02200\" \"368.89681\"\narea_mean            \"0.20376\"   \"1.04290\"   \"1.20252\"   \"0.95738\"  \narea_sd              \"0.07593\"   \"0.29574\"   \"0.44633\"   \"0.33975\"  \narea_ch              \"0.21841\"   \"1.09549\"   \"1.25403\"   \"0.98737\"  \nperimeter            \"2.47874\"   \"6.57315\"   \"6.76831\"   \"6.16784\"  \nradius_mean          \"0.30984\"   \"0.80629\"   \"0.83100\"   \"0.76035\"  \nradius_min           \"0.08719\"   \"0.16293\"   \"0.18562\"   \"0.15426\"  \nradius_max           \"0.55382\"   \"1.52077\"   \"1.55450\"   \"1.42725\"  \nradius_sd            \"0.14009\"   \"0.41090\"   \"0.41521\"   \"0.38635\"  \ndiam_mean            \"0.61969\"   \"1.61258\"   \"1.66199\"   \"1.52070\"  \ndiam_min             \"0.17437\"   \"0.32586\"   \"0.37125\"   \"0.30851\"  \ndiam_max             \"1.10764\"   \"3.04155\"   \"3.10900\"   \"2.85450\"  \nmajor_axis           \"0.32614\"   \"0.88784\"   \"0.90842\"   \"0.83691\"  \nminor_axis           \"0.09119\"   \"0.16641\"   \"0.18464\"   \"0.15716\"  \ncaliper              \"1.08263\"   \"3.00044\"   \"3.06851\"   \"2.81646\"  \nlength               \"1.08175\"   \"3.00048\"   \"3.06880\"   \"2.81631\"  \nwidth                \"0.26380\"   \"0.46698\"   \"0.51461\"   \"0.43114\"  \nradius_ratio         \" 8.25822\"  \"10.63699\"  \"10.35437\"  \" 9.96570\" \ntheta                \"0.06007\"   \"0.02661\"   \"0.10848\"   \"0.19753\"  \neccentricity         \"0.95075\"   \"0.98051\"   \"0.97600\"   \"0.97927\"  \nform_factor          \"0.42003\"   \"0.30940\"   \"0.32598\"   \"0.32386\"  \nnarrow_factor        \"1.00095\"   \"1.00023\"   \"1.00011\"   \"1.00023\"  \nasp_ratio            \"4.59062\"   \"6.92547\"   \"6.39061\"   \"6.73768\"  \nrectangularity       \"1.41147\"   \"1.33254\"   \"1.33934\"   \"1.28724\"  \npd_ratio             \"2.29103\"   \"2.18462\"   \"2.20346\"   \"2.19193\"  \nplw_ratio            \"1.83459\"   \"1.89170\"   \"1.88509\"   \"1.89288\"  \nsolidity             \"0.97648\"   \"1.00830\"   \"1.00417\"   \"1.00802\"  \nconvexity            \"0.79901\"   \"0.85295\"   \"0.84057\"   \"0.83455\"  \nelongation           \"0.75038\"   \"0.84453\"   \"0.83136\"   \"0.84134\"  \ncircularity          \"32.06684\"  \"42.44614\"  \"40.09633\"  \"40.85288\" \ncircularity_haralick \"2.25686\"   \"1.97161\"   \"2.01276\"   \"1.98964\"  \ncircularity_norm     \"0.38197\"   \"0.27674\"   \"0.29551\"   \"0.29044\"  \ncoverage             \"0.00136\"   \"0.00070\"   \"0.00081\"   \"0.00075\"  \n                     5          \nimg                  \"imgA2\"    \nn                    \" 80\"      \narea_sum             \" 21.44658\"\narea_mean            \"0.26849\"  \narea_sd              \"0.12016\"  \narea_ch              \"0.30438\"  \nperimeter            \"2.83415\"  \nradius_mean          \"0.35092\"  \nradius_min           \"0.09725\"  \nradius_max           \"0.62590\"  \nradius_sd            \"0.15732\"  \ndiam_mean            \"0.70185\"  \ndiam_min             \"0.19451\"  \ndiam_max             \"1.25180\"  \nmajor_axis           \"0.36743\"  \nminor_axis           \"0.10928\"  \ncaliper              \"1.22042\"  \nlength               \"1.21789\"  \nwidth                \"0.32062\"  \nradius_ratio         \" 9.67376\" \ntheta                \"0.08814\"  \neccentricity         \"0.94696\"  \nform_factor          \"0.43987\"  \nnarrow_factor        \"1.00180\"  \nasp_ratio            \"4.17961\"  \nrectangularity       \"1.43860\"  \npd_ratio             \"2.30524\"  \nplw_ratio            \"1.82475\"  \nsolidity             \"0.96833\"  \nconvexity            \"0.83413\"  \nelongation           \"0.73372\"  \ncircularity          \"30.65038\" \ncircularity_haralick \"2.29773\"  \ncircularity_norm     \"0.40617\"  \ncoverage             \"0.00170\"  \n\n\nBelow, I will fit a non-linear model (Logistic) to model the leaf area evolution across the crop cycle.\n\nCodelibrary(tidyverse)\n\ndf_plot &lt;- \n  merged$summary |&gt; \n  separate_col(img, \n               into = c(\"avaliacao\", \"das\", \"bloco\")) |&gt; \n  mutate(das = as.numeric(das))\n\n# plot \n\nmy_theme &lt;- \n  theme_bw(base_size = 14) +\n  theme(panel.grid.major = element_blank())\n\n# leaf area\nformula &lt;- y ~ b1/(1 + exp(b2 - b3 * x))\n\nggplot(df_plot, aes(das, area_sum)) + \n  geom_smooth(method = \"nls\",\n              method.args = list(formula = formula,\n                                 start = c(b1 = 248,\n                                           b2 = 6,\n                                           b3 = 0.07)),\n              se = FALSE,\n              color = \"red\") +\n  stat_summary(fun.data = mean_se,\n               geom = \"errorbar\",\n               width = 0.5) +\n  stat_summary(fun = mean,\n               geom = \"point\",\n               col = \"blue\",\n               size = 3) +\n  scale_x_continuous(breaks = unique(df_plot$das)) +\n  scale_y_continuous(breaks = seq(0, 150, by = 25)) +\n  labs(x = \"Days after sowing\",\n       y = expression(Área~foliar~média~(cm^2~planta^{-1}))) +\n  my_theme\n# number of leaves\nformula &lt;- y ~ b1/(1 + exp(b2 - b3 * x))\n\nggplot(df_plot, aes(das, n)) + \n  geom_smooth(method = \"nls\",\n              method.args = list(formula = formula,\n                                 start = c(b1 = 188,\n                                           b2 = 3,\n                                           b3 = 0.05)),\n              se = FALSE,\n              color = \"red\") +\n  stat_summary(fun.data = mean_se,\n               geom = \"errorbar\",\n               width = 0.5) +\n  stat_summary(fun = mean,\n               geom = \"point\",\n               col = \"blue\",\n               size = 3) +\n  scale_x_continuous(breaks = unique(df_plot$das)) +\n  scale_y_continuous(breaks = seq(0, 150, by = 25)) +\n  labs(x = \"Days after sowing\",\n       y = \"Number of leaves per plant\") +\n  my_theme"
  },
  {
    "objectID": "03_analyze.html#filling-holes",
    "href": "03_analyze.html#filling-holes",
    "title": "Analyze objects",
    "section": "\n8.3 Filling ‘holes’",
    "text": "8.3 Filling ‘holes’\nAn important aspect to consider in leaf area measures is when leaves present ‘holes’. This can occur, for example, by the attack of pests. In this case, the area would have to be considered, because it was there! The image bellow is used as an example.\n\nholes &lt;- image_import(\"holes.jpg\", plot = TRUE)\n\n\n\n\nIn this case, the missing area will not be computed using the default settings of analyze_objects(). To include this area as the leaf area, we can use the argument fill_hull(). Note that this will only work for missing areas within a closed object. If the missing area includes the original leaf contour, there is no (yet available) way to reconstruct the leaf perimeter.\n\naf &lt;-\n  analyze_objects(holes,\n                  watershed = FALSE,\n                  col_background = \"white\",\n                  marker = \"area\",\n                  marker_col = \"red\",\n                  marker_size = 3,\n                  plot =  FALSE,\n                  save_image = TRUE,\n                  dir_processed = tempdir(),\n                  contour_size = 5)\n\n# fill the missing area\naf2 &lt;-\n  analyze_objects(holes,\n                  fill_hull = TRUE, # fill ' holes '\n                  watershed = FALSE,\n                  col_background = \"white\",\n                  marker = \"area\",\n                  marker_col = \"red\",\n                  marker_size = 3,\n                  plot =  FALSE,\n                  save_image = TRUE,\n                  prefix = \"proc2_\",\n                  dir_processed = tempdir(),\n                  contour_size = 5)\n\nimgs &lt;- image_import(pattern = \"proc\", path = tempdir())\nimage_combine(imgs)\n\n\n\n\nWe can simply use the ratio between proc_img and proc_img2 to compute the injured area in this leaflet.\n\n# percent of the injured area\n100 - 86432 / 99186 * 100\n\n[1] 12.85867"
  },
  {
    "objectID": "03_analyze.html#compound-leaves",
    "href": "03_analyze.html#compound-leaves",
    "title": "Analyze objects",
    "section": "\n8.4 Compound leaves",
    "text": "8.4 Compound leaves\nA simple leaf blade is undivided. The blade of a compound leaf is divided into several leaflets. In the following examples, I will show how to analyze simple and compound leaves with analyze_objects(), mainly if the goal is to obtain the measures for each leaf (e.g., mean area), where the number of objects (leaves) will influence the results.\nThe following images by Daniel Saueressig were obtained from the Sistema de Identificação Dendrológica Online - Floresta Ombrófila Mista11 and show examples of simple and compound leaves.\n\nimgs &lt;- \n  image_import(c(\"simple.jpg\", \"compound.jpg\")) |&gt; \n  image_horizontal()\nimage_combine(imgs)\n\n\n\n\nAnalyzing non-touching simple leaves is fairly simple. We already did that. The squares in the background have 4 cm\\(^2\\). With this information, it is possible to obtain the image resolution with dpi(simple), which will be useful to adjust the measures. In this case, the estimated dpi is 48.65.\n\nsimple &lt;- imgs$simple.jpg\nsarea &lt;- analyze_objects(simple, marker = \"id\")\n\n\n\n\nNote that with the default settings, the simple leaf was partitioned into small, segmented leaves. This can be solved by either using object_size = \"large\" or watershed = FALSE, to omit the watershed segmentation algorithm. The last is used here.\n\nsarea &lt;- \n  analyze_objects(simple,\n                  watershed = FALSE,\n                  marker = \"id\",\n                  show_chull = TRUE,\n                  contour_size = 6)\n\n\n\nsarea_cor &lt;- get_measures(sarea, dpi = 48.65)\nsarea_cor |&gt; t()\n\n                             1         2\nid                     1.00000   2.00000\nx                    182.30988 177.83018\ny                     67.65594 183.76066\narea                  20.00228  41.39746\narea_ch               31.85154  56.24925\nperimeter             31.52950  41.28656\nradius_mean            3.03137   4.28452\nradius_min             1.09831   1.06972\nradius_max             5.71519   7.95304\nradius_sd              1.21685   1.80229\ndiam_mean              6.06273   8.56904\ndiam_min               2.19662   2.13943\ndiam_max              11.43038  15.90607\nmajor_axis             3.05069   4.36690\nminor_axis             1.16636   1.59089\ncaliper               11.06845  14.95531\nlength                11.06847  15.47434\nwidth                  4.69925   6.04070\nradius_ratio           5.20362   7.43472\ntheta                 -0.00016  -0.07118\neccentricity           0.92403   0.93128\nform_factor            0.25285   0.30519\nnarrow_factor          1.00000   0.96646\nasp_ratio              2.35537   2.56168\nrectangularity         2.60038   2.25801\npd_ratio               2.84859   2.76066\nplw_ratio              1.99962   1.91896\nsolidity               0.62798   0.73596\nconvexity              0.77953   0.67022\nelongation             0.57544   0.60963\ncircularity           49.69980  41.17595\ncircularity_haralick   2.49116   2.37726\ncircularity_norm       0.24365   0.29814\ncoverage               0.08788   0.18188\n\n\nFor compound leaves, if the watershed segmentation is used, leaflets will probably be considered as different leaves, as can be seen below.\n\ncompound &lt;- imgs$compound.jpg\ncarea &lt;- \n  analyze_objects(compound,\n                  show_segmentation = TRUE,\n                  show_contour = FALSE,\n                  marker = \"id\")\n\n\n\n\nTherefore, using watershed = FALSE will solve this problem, since all leaflets connected by at least one pixel will be considered part of the same leaf.\n\ncarea &lt;- \n  analyze_objects(compound,\n                  watershed = FALSE,\n                  show_segmentation = TRUE,\n                  show_contour = FALSE,\n                  show_chull = TRUE,\n                  marker = \"id\")\n\n\n\ncarea_cor &lt;- get_measures(carea, dpi = 49.5)\ncarea_cor |&gt; t()\n\n                             3         4\nid                     3.00000   4.00000\nx                     89.22055 242.57443\ny                    111.31761 112.69170\narea                  18.84728  15.83509\narea_ch               43.16207  33.09070\nperimeter             54.54305  48.70669\nradius_mean            2.54616   2.24631\nradius_min             0.05956   0.02471\nradius_max             5.93998   4.94236\nradius_sd              1.26133   1.14489\ndiam_mean              5.09232   4.49263\ndiam_min               0.11913   0.04943\ndiam_max              11.87996   9.88471\nmajor_axis             2.20953   2.05408\nminor_axis             1.78609   1.46145\ncaliper                9.27193   7.37643\nlength                 9.33971   8.10641\nwidth                  7.14337   6.44205\nradius_ratio          99.72535 199.98693\ntheta                 -1.23490   1.29832\neccentricity           0.58869   0.70270\nform_factor            0.07961   0.08388\nnarrow_factor          0.99274   0.90995\nasp_ratio              1.30747   1.25836\nrectangularity         3.53988   3.29786\npd_ratio               5.88260   6.60302\nplw_ratio              3.30903   3.34789\nsolidity               0.43666   0.47854\nconvexity              0.38233   0.41166\nelongation             0.23516   0.20531\ncircularity          157.84475 149.81551\ncircularity_haralick   2.01864   1.96203\ncircularity_norm       0.07452   0.07817\ncoverage               0.08572   0.07202"
  },
  {
    "objectID": "03_analyze.html#functions",
    "href": "03_analyze.html#functions",
    "title": "Analyze objects",
    "section": "\n10.1 Functions",
    "text": "10.1 Functions\nThe functions were adapted from Claude (2088)12"
  },
  {
    "objectID": "03_analyze.html#elliptical-fourier",
    "href": "03_analyze.html#elliptical-fourier",
    "title": "Analyze objects",
    "section": "\n10.2 Elliptical fourier",
    "text": "10.2 Elliptical fourier\n\nlibrary(pliman)\nimgs &lt;- image_import(pattern = \"img\", path = \"fourier\")\nnames(imgs) &lt;- paste0(\"ind\", 1:9)\n\nconts &lt;- \n  object_contour(imgs,\n                 index = \"B\",\n                 watershed = FALSE,\n                 plot =  FALSE)\n\n\nef &lt;- efourier(conts, nharm = 30)\nefi1 &lt;- efourier_inv(ef[[8]], nharm = 5)\nefi2 &lt;- efourier_inv(ef[[8]], nharm = 10)\nefi3 &lt;- efourier_inv(ef[[8]], nharm = 30)\n\nplot(imgs[[8]])\nplot_contour(efi1)\nplot_contour(efi2, col = \"red\")\nplot_contour(efi3, col = \"blue\")"
  },
  {
    "objectID": "03_analyze.html#rotation-and-size",
    "href": "03_analyze.html#rotation-and-size",
    "title": "Analyze objects",
    "section": "\n10.3 Rotation and size",
    "text": "10.3 Rotation and size\n\nlibrary(pliman)\nimg &lt;- image_import(\"changes.png\", path = \"fourier\")\ncont &lt;- \n  object_contour(img,\n                 index = \"B\",\n                 watershed = FALSE,\n                 plot =  FALSE)\n\n\nef &lt;- \n  efourier(cont) |&gt; \n  efourier_norm() |&gt; \n  efourier_coefs()\nef\n\n  object A1          A2           A3          A4          A5          A6\n1      1  1 -0.02075229 -0.001967149 -0.02243785 -0.01051923 -0.02631046\n2      2 -1  0.05347429  0.005280597  0.03800024  0.01186258  0.05128006\n3      3  1 -0.01316395 -0.002955584 -0.01750128 -0.01291722 -0.02049034\n             A7           A8           A9          A10            B1         B2\n1  0.0015605953 -0.006927166 -0.011259484  0.004915726 -3.044942e-17 -0.3949627\n2 -0.0005919858  0.014879933  0.009298835 -0.010101305 -2.785724e-16  0.3912420\n3  0.0010814994 -0.003907685 -0.010955053  0.004655006  7.638715e-18 -0.3969607\n             B3         B4           B5          B6           B7          B8\n1 -0.0003923146 -0.1202646 -0.002084410 -0.09945037 -0.002193451 -0.03342269\n2  0.0146176740  0.1166273 -0.001846976  0.08874169  0.002321198  0.03056498\n3  0.0030213897 -0.1212294 -0.001632096 -0.09895883 -0.001303100 -0.03134100\n             B9         B10            C1          C2          C3          C4\n1 -0.0002261568  0.01457887  0.000000e+00  0.10442995  0.03222546 -0.06960008\n2 -0.0050153344 -0.01110277 -3.482156e-16 -0.09969635 -0.07453366  0.06915561\n3 -0.0006675290  0.01620912  3.819357e-18  0.10565086  0.02465100 -0.06874620\n           C5          C6           C7          C8           C9          C10\n1  0.01617662  0.04154609  0.009682157 -0.04718118 -0.001724962  0.007288867\n2 -0.02598072 -0.03852236 -0.019599632  0.04202645  0.006442364 -0.006935145\n3  0.01291151  0.04239523  0.006671048 -0.04783110 -0.001079465  0.006609363\n          D1          D2         D3           D4          D5           D6\n1 -0.9523335 -0.01969877  0.3351972 -0.001506831  0.04915802 -0.003672522\n2  0.9531687  0.04780208 -0.3290529 -0.006601458 -0.04505256  0.016706985\n3 -0.9502921 -0.01514573  0.3383713 -0.001711505  0.05055679 -0.001177859\n           D7          D8           D9          D10\n1  0.03955211  0.01431461 -0.010822192 0.0011125890\n2 -0.03592838 -0.02672881  0.008299971 0.0010049357\n3  0.03811810  0.01118330 -0.011920117 0.0006020825"
  },
  {
    "objectID": "03_analyze.html#morphological-diversity",
    "href": "03_analyze.html#morphological-diversity",
    "title": "Analyze objects",
    "section": "\n10.4 Morphological diversity",
    "text": "10.4 Morphological diversity\n\nconts &lt;- \n  object_contour(imgs,\n                 index = \"B\",\n                 watershed = FALSE,\n                 plot =  FALSE) |&gt; \n  efourier() |&gt; \n  efourier_norm() |&gt; \n  efourier_coefs()\n\n\ncoefs &lt;- \n  conts |&gt; \n  dplyr::select(-object) |&gt; \n  dplyr::mutate(specie = c(rep(paste0(\"specie\", 1:3), each = 3)), .before = 1)\n\n\nlibrary(factoextra)\n\nWelcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa\n\n\n\nAttaching package: 'factoextra'\n\n\nThe following object is masked from 'package:metan':\n\n    get_dist\n\nlibrary(FactoMineR)\n\nWarning: package 'FactoMineR' was built under R version 4.2.3\n\npca &lt;- PCA(coefs, quali.sup = 1, graph = FALSE)\nfviz_pca_ind(pca, habillage = 1, repel = TRUE)\n\n\n\nimage_combine(imgs)"
  }
]